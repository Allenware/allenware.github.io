<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[python-扬帆起航]]></title>
      <url>%2F2017%2F04%2F08%2Fpython-%E6%89%AC%E5%B8%86%E8%B5%B7%E8%88%AA%2F</url>
      <content type="text"><![CDATA[前言闲着无聊，重学python，记录总结。 Life is short,I use python. —From person I don’t konw [TOC] 学习环境linux和mac与生俱来，就比windows更适合windows。毕竟他们都是秉持着 一切皆对象 的原则。 python的安装无需多说，对于版本，我的看法是顺着时代，抛弃python2.x吧，虽然工作中很多库都建立在python2的依赖之上。但对于我们个人，直接学习python3.x是更聪明的选择。我的python版本是3.6 最好的学习资料还是推荐官方文档，有中文版 下面这张图是我偶然看见的，说明了python很多常用的语法 开发工具用过vim的小伙伴当然是不用多想，vim很适合开发python。 如果是喜欢IDE的童鞋，那就肯定是Pycharm了。jetbrains的软件都是非常赞的。当然python新手也推荐用这款软件，我之前也是一直在用，唯一的缺点就是启动时加载项目太慢了。 我自己使用的是sublime text3和相关的python package，sublime3界面比较好看，颜值吸引了我，专有的包管理器，扩展性不错。至于怎么配置，网上还是很多分享的。这里我只推荐两个package SublimeREPL ,这样就无需重复的保存，取cmd执行.py文件。在editor中可以直接编译运行py脚本 sublime3已经支持了函数声明跳转功能，但在项目文件变得杂多时，跳转结果并不准确，推荐ctags。这个大名鼎鼎的插件就不用多说了 上面三种方法对于初学者还是比较麻烦，尤其是第一和第三种。所以python3之后加入了idle代码解释器，下载之后，可以直接使用python自带的cmdline或者Idle的交互环境先学起来。 提示python解释器的注释 编码方式 1# -*- coding: utf-8 -*- 指定执行脚本的python解释器，必须在第一行，推荐下面的写法，让操作系统在env中寻找python解释器的路径 1#!/usr/bin/env python3 python中的字符串基本python支持单引号 &#39;str&#39; 和双引号 &quot;str&quot; 来修饰字符串，\ 用来转义。 123456789101112&gt;&gt;&gt; 'spam eggs' # single quotes'spam eggs'&gt;&gt;&gt; 'doesn\'t' # use \' to escape the single quote..."doesn't"&gt;&gt;&gt; "doesn't" # ...or use double quotes instead"doesn't"&gt;&gt;&gt; '"Yes," he said.''"Yes," he said.'&gt;&gt;&gt; "\"Yes,\" he said."'"Yes," he said.'&gt;&gt;&gt; '"Isn\'t," she said.''"Isn\'t," she said.' 可以看出来，单引号和双引号，相互之间的影响，是可以嵌套作用的。当然不推荐将简单的字符串写的如此复杂。 选用一种引号，再加上转义字符 \ 和 原始字符串 可以处理绝大部分的字符串。 原始字符串 ：r . r&#39;str&#39; 中的str默认不转义 12345&gt;&gt;&gt; print('C:\some\name') # here \n means newline!C:\someame&gt;&gt;&gt; print(r'C:\some\name') # note the r before the quoteC:\some\name 上面也可以用 print(&#39;C:\some\\name&#39;) 来避免冲突，但是明显不如使用 原始字符串 理解起来方便。 格式化和C语言类似，利用 % 来格式化输出，%s %d %f %x 分别用来代替字符串/整数/浮点数和十六进制整数,称为占位符。分不清楚的时候可以无需考虑直接使用 %s 1234&gt;&gt;&gt; 'Hello, %s' % 'world''Hello, world'&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)'Hi, Michael, you have $1000000.' 除了使用 % 来格式化，功能更多，使用起来更方便的是字符串自带的格式化函数 format ，具体用法看 str.format123456789101112131415161718192021222324252627282930313233343536# 位置参数print "&#123;0&#125; is &#123;1&#125; years old".format("Wilber", 28)print "&#123;&#125; is &#123;&#125; years old".format("Wilber", 28)print "Hi, &#123;0&#125;! &#123;0&#125; is &#123;1&#125; years old".format("Wilber", 28)# 关键字参数print "&#123;name&#125; is &#123;age&#125; years old".format(name = "Wilber", age = 28)# 下标参数li = ["Wilber", 28]print "&#123;0[0]&#125; is &#123;0[1]&#125; years old".format(li)# 填充与对齐# ^、&lt;、&gt;分别是居中、左对齐、右对齐，后面带宽度# :号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充print '&#123;:&gt;8&#125;'.format('3.14')print '&#123;:&lt;8&#125;'.format('3.14')print '&#123;:^8&#125;'.format('3.14')print '&#123;:0&gt;8&#125;'.format('3.14')print '&#123;:a&gt;8&#125;'.format('3.14')# 浮点数精度print '&#123;:.4f&#125;'.format(3.1415926)print '&#123;:0&gt;10.4f&#125;'.format(3.1415926)# 进制# b、d、o、x分别是二进制、十进制、八进制、十六进制print '&#123;:b&#125;'.format(11)print '&#123;:d&#125;'.format(11)print '&#123;:o&#125;'.format(11)print '&#123;:x&#125;'.format(11)print '&#123;:#x&#125;'.format(11)print '&#123;:#X&#125;'.format(11)# 千位分隔符print '&#123;:,&#125;'.format(15700000000) 多行字符串python使用三引号来处理多行字符串 12345print("""\Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to""") 字符串的高级特性 索引 字符串可以通过index访问，如 1str[0],str[1], ... str[len(str)-1] 还可以逆序访问 1str[-1],str[-2], ... 其中 str[len(str)-1] = str[-1] 切片 切片表达式 : str[a:b:c]从str字符串，按步长c，从下限a到上限b (不包含上限)，取出单个字符组成字符串 1234567&gt;&gt;&gt; word = 'abcdefghijklmn'&gt;&gt;&gt; word[0:3] # characters from position 0 (included) to 2 (excluded)'abc'&gt;&gt;&gt; word[5:10:2]'fhj'&gt;&gt;&gt; word[-10:-1:2]'ehikm' 当然不只是 字符串 这种数据类型才有 切片 特性，切片特性是可迭代对象共有的。 字符串是python中少有的不可变对象 python是动态语言，其中的不可变对象很少，比如tuple，字符串也是其中一种。 字符串的常用内置函数字符串是python的基本数据类型，但本质上，它是python封装的一个类对象，拥有着很多属性。 1234&gt;&gt;&gt;type(str)&lt;class 'type'&gt;&gt;&gt;&gt;dir(str)['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] dir(str) 以 list 的形式给出了字符串这个类的所有属性。常用的有： str.capitalize() 将字符串第一个元素大写 str.find(string,beg=0,end=len(str)) 检查str中是否还有string，找到返回起始索引 str.join(seq) 以str作为分隔，将seq中所有元素组成一个新的字符串 123&gt;&gt;&gt;word = 'Allenware'&gt;&gt;&gt;'-'.join(word)'A-l-l-e-n-w-a-r-e' str.split(str=&quot;&quot;,num=str.count(str)) 以 str 为分隔符切片 string，如果 num有指定值，则仅分隔 num 个子字符串 str.partition(str) 按string将str分为三段，返回一个包含三个元素的元组 123&gt;&gt;&gt;string='Allenware is very cool!'&gt;&gt;&gt;string.partition('is')('Allenware ', 'is', ' very cool!') str.strip() = str.lstrip() + str.rstrip() 截掉str左边右边空格 str.upper str.lower大小写转换]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[http协议]]></title>
      <url>%2F2017%2F04%2F08%2Fhttp%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[[TOC] Http DefinitionHTTP（Hypertext Transfer Protocol）就是超文本传输协议，它是现代互联网最重要也是最基本的协议。Http协议是无状态的、应用层协议，它是web开发的基础。 URL URL(Uniform Resource Locator) 地址用于描述一个网络上的资源。基本格式如下： 1234567891011schema://login@host[:port#]/path/..../[?query-string][#anchor] /* scheme: 协议名（如http,https,ftp） login: 登陆信息 host: 服务器IP/域名 port#:HTTP服务的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如http://www.cnblogs.com:8080 path: 资源路径 query-string: 发送给web服务器的数据 anchor: 锚 */ 举个例子： 123456789http://www.mywebsite.com/sj/test/test.aspx?name=sivergn&amp;x=true#stuff /* schema: http host: www.mywebsite.com path: /sj/test/test.aspx Query String: name=sviergn&amp;x=true Anchor: stuff */ URL的请求过程 当你在浏览器输入URLhttp://www.website.com的时候，浏览器发送一个Request去获取http://www.website.com的html。 服务器把Response发送回给浏览器。浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件。 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。当所有的文件都下载成功后， 网页就被显示出来了。 Request Method我们通过URL访问服务端获得资源，具体的操作由 http 协议的 request method 来定义。http/1.1 一共有八种操作： GET：向服务端发起获得资源的请求。GET 也是可以传递参数给服务端的，是将参数放在URL中携带到服务端，暴露在整篇网络环境中，很不安全。 POST：向指定的主机资源提交数据。一般都是向服务端提交表单数据进行处理。POST 提交的数据保存在http协议的body中。 PUT：向指定的主机资源上传最新的内容 DELETE：请求服务端删除Request-URL标识的资源 上面四种是用的最多的四种Method，有时候，我们将 PUT 和 DELETE 看作是POST的特殊实现。 HEAD：与GET方法类似，区别是只请求头部。用于测试和获得头部中的元数据 TRACE：回显请求 CONNECT：HTTP/1.1预留给一些代理服务器用，用于改变连接方式。 OPTIONS：测试服务端能支持的HTTP Method 对于Method常见的错误码： 405（Method Not Allowed） 是客户端的错误 501（Not Implemented） 是服务端的错误 GET实例： 1234GET /test/?id=11101&amp;name=Professional HTTP/1.1Host: www.test.comUser-Agent: Mozilla/5.0 (Windows; U;) Firefox/1.0.1Connection: Keep-Alive POST实例： 12345678POST / HTTP/1.1Host: www.test.com User-Agent: Mozilla/5.0 (Windows; U) Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivename=Professional&amp;id=11101 状态码通过URL和Method，客户端就可以发送一个完整的请求给服务端。当然服务端也会做出响应。状态码就是非常重要的一种响应，客户端通过状态码就可以了解服务端做出何种响应。HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别： 1XX 提示信息； 表示请求已被成功接收，告诉客户端可以继续发送下一个请求了，若如果已发送完毕可以忽略它。 2XX 成功 3XX 重定向； 要完成请求必须进行更进一步的处理 4XX 客户端错误；请求有语法错误或请求无法实现 5XX 服务器端错误；服务器未能实现合法的请求 常见的状态码1xx：Informational Messages这是 http/1.1 才支持的状态码，服务端可以发送一个 100-continue 告诉客户端继续发送消息，客户端如果已发送可以忽略。 2xx：成功告诉 client 接收到 Request 并成功处理，最常见的是 200 OK 202 Accepted: the request was accepted but may not include the resource in the response. This is useful for async processing on the server side. The server may choose to send information for monitoring. 204 No Content: there is no message body in the response. 205 Reset Content: indicates to the client to reset its document view. 206 Partial Content: indicates that the response only contains partial content. Additional headers indicate the exact range and content expiration information. 3xx：Redirection这个状态代表客户端需要重定向到其他URL获取资源，新的URL在Response中，浏览器会自动向新的URL发起Request 301 请永久到新的URL获取资源 303 资源暂时位于新的URL，新的URL记在 Location Response Header 中 304 告诉client请求的资源没有更新，可以直接使用client缓存中的备份。（当然有没有更新是靠头部中的标识进行hash计算的） 4xx：Client Error当客户端发出一个 bad request 或者请求无效资源时，server端会认为时client出错了。最常见的是 404 Not Found 。404 表示资源无效，在服务端上不存在。 400 Bad Request：请求语法错误 401 Unauthorized： 未经授权。可以通过带有 Unauthorized 的头部再次发起请求。还是401错误应该可以推断是没有证书。 403 Forbidden：服务器收到请求，但是拒绝提供服务 405 Method Not Allowed：request line中的method不合法 409 Conflict：冲突了。通常出现在多人协作时。 5xx：Server Error用于来表示server端出现了故障。最常见的是 500 Internal Server Error 服务器发生不可预期的错误。 501 Not Implemented：服务器不支持此方法 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常 Http消息结构消息格式http协议对 Request 和 Response 两种消息定义了下面的格式： 1234567message = &lt;start-line&gt; *(&lt;message-header&gt;) CRLF [&lt;message-body&gt;]&lt;start-line&gt; = Request-Line | Status-Line&lt;message-header&gt; = Field-Name ':' Field-Value 从上面定义我们可以看到，Http的Request和Response消息都是由三部分组成： 1231. start-line 开始行 2. header 消息头 3. body 消息体 对于start-line，又分为： 121. Request-Line : 'METHOD/path-to-resource http-version'2. Response-Line : 'http-version status-code message' 对于Headers则有如下几种： 123451. general headers2. entity headers3. request or response headers a. request specific headers. b. response specific headers. Request12GET http://www.google.com/ HTTP/1.1Host:www.google.com 用表格来表示： Request Line METHOD/path-to-resource HTTP/version-number Request Header Field1 : Value Request Header Field2 : Value 空行 空行 Request Body data(optional) Request Line／请求行 Method ：请求方法，如GET/POST path-to-resource ：所请求的资源在web服务器上的位置 HTTP/version-number：HTTP协议版本号。 Request Header，记录请求行以外的重要信息。 Request Body，携带提交给web服务器的数据。使用GET方法时，为空。 注意，Body和Header之间空一行。 Response Response Line HTTP/version-number status-code message Response Header Field1 : Value Response Header Field2 : Value 空行 空行 Response Body data(optional) Response Line／响应行 HTTP/version-number ：HTTP协议版本号 status-code ：状态码，反应服务器处理是否正常，告知出现的错误 message ：状态消息，同状态码对应。 Response Header / 响应头 ：记录响应体数据的相关信息。 Response Body / 响应体 ：携带需要向web服务器发送的数据。使用GET方法时，为空。 TIPs 对于GET方法，例如Http://localhost/login.php?username=aa&amp;password=1234 ，很明显能辩认出 ? 后就是 query-string ，易被网络爬虫爬取信息。 对于POST ，则会将提交的数据保存到HTTP的BODY中，比如上面的 username=aa&amp;password=1234 Reference 云栖社区 Http协议详解 HTTP协议详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为什么不用Markdown写设计文档?]]></title>
      <url>%2F2017%2F04%2F03%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8Markdown%E5%86%99%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[why write this blog之前只有在用一些笔记软件的时候偶尔接触过markdown这个东西，只知道是一种轻型的标记语言。现在工作还有各方面的需要，必须抽出一些时间系统的学习一下markdown。当然并不研究markdown的渲染原理，只学习用法。 [TOC] Markdown简介wiki上的介绍 Markdown is a lightweight markup language with plain text formatting syntax. It’s designed so that it can be converted to HTML and many other formats using a tool by the same name. 这么看，markdown的设计初衷肯定不是面向码农了，受众应该是经常写文档，写邮件的办公室一族了。 Markdown提供一套规定的语法，让写出的文档经过markdown processer的处理，转化为html，从而格式化你的.md文件。 当然，到了现在，Markdown的使用范围和影响已经渗透到各个行业，许多人日常的工作经常需要和它打交道。Github天生对md文件的支持，国内博客如简书也流行起markdown的方式来写博客。而抽出一小时左右的时间就能学会并使用它，还是非常值得，希望这篇blog会对你们有所帮助。 Editor工欲善其事，必先利其器。这里我推荐typero 下面是我写这篇博客时的截图 功能齐备 mac/windows的跨平台支持 界面清爽，cold style markdown的语法建和快捷键的绑定 准备好之后，开始markdown的学习。 区块元素标题标题用 # 来提示markdown引出标题，一共有六级标题，字体从大到小。合理的在一篇文章中使用标题，可以通过 [toc] 自动生成目录，而且让你的文章层次更加清楚。 1234# header1## header2...####### header6 header效果： 引用使用 &gt; 符号，引用的范围很广，通用解释、官方定义、他人专利都推荐用引用格式。 1&gt; 输入引用的内容 blockquotes效果： 列表un-orded list使用 - 来创建无序列表，+ * 具有相同的作用。 12345## programming language- c++- pyhton- go- java orded list有序列表，使用 1. item1 来创建，可以不按顺序，markdown语法解析器会自动识别 1234## popular1. javascipt2. pyhthon 3. java task list也就是html中的复选框，使用 - [] 来创建，默认不选中，- [x] 为默认选中的复选框 123- [] option1- [] option2- [x] options 效果如下： [ ] option1 [ ] option2 [x] option3 code block很多博客和笔记软件都支持加入代码块这个功能，可以保持代码的原貌。在typero中是使用 ` 来加入代码块，其他editor可能略有不同。1234```pythonfor a in list func(a) linksmarkdown支持两种link方式，inline和reference。两种方式都是用 [ ] 来修饰需要链接的对象。 inline links 在需要链接的对象后面，用括号加上links即可。用符号表示就是 [object] 后面加上 (links &quot;title&quot;) title是可选项。如果链接访问的本地主机的资源，可以用相对路径代替url 123[Baidu](http://baidu.com/ "baidu") is a famous company.See my [About](/about/) page for details. 效果： Baidu is a famous company. See my About page for details. reference links 与inline不同的是，它不直接指明链接的地址。而是在 [object] 后面跟上一个 [identifier] ，然后在文件的合适地方，给identifier定义一个links，这样object就能通过唯一的identifier找到自己的links。如果 [identifier] 为空，则默认和 [object] 同名 123[Tencent][qq] has been the best internet company in Asia.[qq]: http://allenware.github.io "Allenware" 效果： Tencent has been the best internet company in Asia. imagesimages的用法和links基本相似，只是加了一个 ! 在前面 inline式的语法如下： 123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg "Optional title") reference式的语法如下： 123![Alt text][id][id]: url/to/image "Optional title attribute" table创建表格，使用|header1|header2|...|headern| 来创建n列的表格，自动生成表格之后可以调节表格大小。 id name score 1 Allen 100 2 James 90 3 Victoria 95 Footnotes创建脚注 123You can create footnotes like this[^footnote].[^footnote]: Here is the *text* of the **footnote**. 效果： You can create footnotes like this[^footnote]. [^footnote]: Here is the text of the footnote. TIPs 需要注意markdown中有意义的符号，在写文章时可能会出现冲突，比如下面这个例子 11994. the year i was born 我的目的只是将它作为普通语句输入，解释markdown的语法解析器会把它误认为列表的提示键，这种情况需要引入 \ 转义符，正确用法如下 11994\. the year i was born 强调语法，使用**word** 来加粗，*word* 使字体变斜 _ 和 * 是同样的作用 TOC 用法，使用 [toc] 来生成目录，前面已介绍 下划线，可以使用下面的符号生成 1234---------********* 简短的代码引用可以用code就可以，比如 printf 是输出语句 插入image稍微麻烦一些，本地图片很方便，其他的可以用七牛云图片存储。 :smile :happy: 可以输入emoji ​比如：:open_hands: :clap: :haha: ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F02%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
