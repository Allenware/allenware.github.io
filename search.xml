<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[http消息]]></title>
      <url>%2F2017%2F04%2F09%2Fhttp%E6%B6%88%E6%81%AF%2F</url>
      <content type="text"><![CDATA[HeadersHTTP协议的Header总共分为三种，分别是General Headers、Entity Headers、Request/Response Headers 。目前最新的是基于HTTP/1.1的RFC2616，总共规定了47种头部字段。 [TOC] General Headers我把被Request和Response共享的Headers成为General Headers，具体有： 123456789general-header = Cache-Control | Connection | Date | Pragma | Trailer | Transfer-Encoding | Upgrade | Via | Warning Cache -Control 指定请求和响应遵循的缓存机制，单向work 12345Cache-Control:Public 可以被任何缓存所缓存Cache-Control:Private 内容只缓存到私有缓存中Cache-Control:no-cache 所有内容都不会被缓存 Connection 允许客户端和服务器指定与请求/响应连接有关的选项，keep-alive或者close Date 提供日期和时间标志,说明报文是什么时间创建的 Pragma 头域用来包含实现特定的指令，最常用的是Pragma:no-cache，和 Cache-Control：no-cache 作用相同。用于Http/1.1之前的版本还没有实现 Cache-Control 字段 Trailer 如果报文采用了分块传输编码(chunked transfer encoding) 方式,就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合 Transfer-Encoding 告知接收端为了保证报文的可靠传输,对报文采用了什么编码方式 Upgrade 给出了发送端可能想要”升级”使用的新版本和协议 Via 显示了报文经过的中间节点(代理,网嘎un) Entity HeadersEntityHeaders主要用来描述消息体（message body）的一些元信息，具体有： 12345678910entity-header = Allow | Content-Encoding | Content-Language | Content-Length | Content-Location | Content-MD5 | Content-Range | Content-Type | Expires | Last-Modified 其中，以Content为前缀的Headers主要描述了消息体的结构、大小、编码等信息，Expires描述了Entity的过期时间，Last-Modified描述了消息的最后修改时间。 Content-Length：消息的内容长度 Content-Type：请求实体对应的MIME信息，application/x-www-form-urlencoded或者响应返回的MIME类型 Content-Type: text/html; charset=utf-8 Expires：浏览器会在指定时间前都使用本地缓存 Last-Modified：用于指示资源的最后修改时间 Content-Encoding：服务端支持的返回内容压缩编码类型 Content-Location：请求资源可替代的另一地址 Content-Range：在整个返回体中本部分的字节位置 Allow：允许的Method，只出现在状态码为405的响应消息中 Request Headers在Request-Line后面紧跟着的就是Headers。我们在上面已经介绍了General Headers和Entity Headers，下面便是Request Headers定义： 1234567891011121314151617181920request-header = Accept | Accept-Charset | Accept-Encoding | Accept-Language | Authorization | Expect | From | Host | If-Match | If-Modified-Since | If-None-Match | If-Range | If-Unmodified-Since | Max-Forwards | Proxy-Authorization | Range | Referer | TE | User-Agent | Cookie Request Headers 扮演的角色其实就是一个Request消息的调节器。需要注意的是若一个headers名称不在上面列表中，则默认当做Entity Headers的字段。在HTTP/1.1中，除了HOST字段，其他都是可选的。 前缀为 Accept 的headers定义了客户端可以接受的媒介类型、语言和字符集等 Acceppt：text/html 代表浏览器可以接受的类型为 text/html，如果服务器无法返回html文档，会返回406。一般浏览器可以处理任何类型 Accept：*/* Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（compress，gzip） Accpet-Language：申明自己接收的语言 Accept-Charset：申明接收的字符集，如utf-8 From, Host, Referer 和User-Agent详细定义了客户端 如何初始化Request User-Agent：告诉服务端，消息来源的OS和浏览器信息 Referer：请求的上下文信息，即上一个网页的地址 Host：必须的报文头字段，指定服务端的域名和端口号，通常从url解析 From：发出请求用户的email Range：请求实体的一部分，指定范围 bytes=500-999 前缀为 If 的headers规定了服务器只能返回符合这些描述的资源，若不符合, 则会返回304 Not Modified。 If-Modified-Since ：带上浏览器缓存页面的最后修改时间，Server端会对比实际文件的最后修改时间（Response消息的Last-Modified字段），一样则返回304，有修改返回200 OK和文件内容。客户端丢弃旧内容，缓存新内容。 If-None-Match ：和Etag一起work，Client端再次请求同个资源时，带上上次Server端Response消息的Etag字段到If-None_Match中 若Request-Line中的Method为GET，请求中不包含消息体，若为POST，则会包含消息体。 一个具体的Request消息实例： 123456GET /articles/http-basics HTTP/1.1Host: www.articles.comConnection: keep-aliveCache-Control: no-cachePragma: no-cacheAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Response Headers下面是response-header的定义： 12345678910response-header = Accept-Ranges | Age | ETag | Location | Proxy-Authenticate | Retry-After | Server | Vary | WWW-Authenticate | Set-Cookie Age： 表示消息自server生成到现在的时长，单位是秒 ETag： 是对Entity进行MD5 hash运算的值，用来检测更改 Location： 被重定向的URL Server： 服务器标识 Vary：告诉下有代理是使用缓存还是从原始服务器请求 Set-Cookie：设置http Cookie]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python-常用数据结构]]></title>
      <url>%2F2017%2F04%2F09%2Fpython-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[Python学习笔记2-常用数据类型[TOC] python为何这么简洁方便python非常的简洁，如果用C语言100行才能干的事儿，python只需要10行、5行甚至一行。很重要的一个原因就是python支持的这些高级数据结构，节省了很多代码量。 List列表是python中最常用的数据类型。list是有序的集合，可以随时添加删除元素 [item1,item2 ...] 语法上是 [] 中的元素组成的有序集合，元素不必是同一类型，List中可以有List元素。 123&gt;&gt;&gt;language=['c','java','python']&gt;&gt;&gt;language['c','java','python'] 和 字符串 一样，List同样可以被索引和切片，List也是可迭代对象，不同的是List是可变数据类型。 常用API list(obj) 将对象强制转成list，比如 list(range(5)) list.append(obj) 在列表尾追加 obj list.insert(index,obj) index索引处插入 obj list.pop(obj=list[-1]) 移除列表中的元素(默认最后一个) list.remove(obj) 移除obj匹配的第一个对象 1234567891011121314&gt;&gt;&gt;s=[1,2,3,4,5,[6,7,8],9]&gt;&gt;&gt;s.append(0)[1, 2, 3, 4, 5, [6, 7, 8], 9, 0]&gt;&gt;&gt;s.insert(-1,-1)[1, 2, 3, 4, 5, [6, 7, 8], 9, -1, 0]&gt;&gt;&gt;s.pop(-5)[1, 2, 3, 4, 5, 9,-1, 0]&gt;&gt;&gt;s.sort()[-1, 0, 1, 2, 3, 4, 5, 5, 9]&gt;&gt;&gt;s.reverse()[9, 5, 5, 4, 3, 2, 1, 0, -1]&gt;&gt;&gt;s.count(5)2 利用python为list提供的这些API，我们可以很轻松实现栈和队列这两个数据结构，当然是在你不考虑插入查找操作的复杂度基础上。python的 collections ^collections 这个库中的队列是更好的选择。 12345678910&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; queue = deque(["Eric", "John", "Michael"])&gt;&gt;&gt; queue.append("Terry") # Terry arrives&gt;&gt;&gt; queue.append("Graham") # Graham arrives&gt;&gt;&gt; queue.popleft() # The first to arrive now leaves'Eric'&gt;&gt;&gt; queue.popleft() # The second to arrive now leaves'John'&gt;&gt;&gt; queue # Remaining queue in order of arrivaldeque(['Michael', 'Terry', 'Graham']) List的生成1.直接定义直接用[item1,item2, ...] 穷举法来构造处List 2.迭代在Python中，迭代是通过for ... in来完成的，而很多语言比如C或者Java，迭代list是通过下标索引完成的。python的抽象程度更高，对于 dict{key:value} 可以用 for key in dict 来进行迭代另一方面，python的迭代更加的通用，它适用于所有可迭代对象。可以用下面方法判断是否为可迭代对象 123&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance(List, Iterable) True 生成一个List很简单，结合之前的API和 for 关键字 123456&gt;&gt;&gt; squares = []&gt;&gt;&gt; for x in range(10):... squares.append(x**2)...&gt;&gt;&gt; squares[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 当然对于python而言，这种写法已经算是复杂了，之后会接触很多实用的python高级函数。 3.列表生成式上面的迭代写法，如果用列表生成式来写，那就是 1squares = [x**2 for x range(10)] python的语义已经非常清楚了，多写几次就能很快熟悉了。 列表生成式很大程度的体现了python的简洁高效的特点，还可以在表达式中添加过滤条件，处理函数等等。 12345678910&gt;&gt;&gt; vec = [-4, -2, 0, 2, 4]&gt;&gt;&gt; [x*2 for x in vec][-8, -4, 0, 4, 8]&gt;&gt;&gt; [x for x in vec if x &gt;= 0][0, 2, 4]&gt;&gt;&gt; [abs(x) for x in vec][4, 2, 0, 2, 4] 稍微复杂一些的用法 12345678910&gt;&gt;&gt; freshfruit = [' banana', ' loganberry ', 'passion fruit ']&gt;&gt;&gt; [weapon.strip() for weapon in freshfruit]['banana', 'loganberry', 'passion fruit']&gt;&gt;&gt; [(x, x**2) for x in range(6)][(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]&gt;&gt;&gt; vec = [[1,2,3], [4,5,6], [7,8,9]]&gt;&gt;&gt; [num for elem in vec for num in elem][1, 2, 3, 4, 5, 6, 7, 8, 9] Tuple元组是不可变对象，初始化之后就不可更改。所以，tuple 没有list中append() insert()这样的操作函数，tuple中的元素不可修改。在代码中，tuple带来的好处很多，要大胆的使用它。构造语句： 1&gt;&gt;&gt; t=(1,2,3,4,5) tuple的概念有一点很绕，tuple对象不可变，但是tuple可以包含list这种可变的对象。 1234567&gt;&gt;&gt; t = 12345, 54321, 'hello!'&gt;&gt;&gt; t[0] = 1...会提示修改失败&gt;&gt;&gt; t = ([1,2,3],4,5)&gt;&gt;&gt; t[0][2] = 4&gt;&gt;&gt; tt = ([1,2,4],4,5) 上面的例子，t这个tuple本身并没有变，只是其中的第一个元素内容变了。因为t[0]指向了list类型的可变对象。理解这一点，tuple就很简单了。 Setset可以看成是无重复，无序key的集合，它和数学中的集合一样，两个set之间可以进行交并的操作。 使用 set() 或者 { } 来创建，经常用于重复测试或者关系测试。 重复插入虽然不犯错，但不实际存储。 12345678910111213141516&gt;&gt;&gt; basket = &#123;'apple', 'orange', 'apple', 'pear', 'orange', 'banana'&#125;&gt;&gt;&gt; print(basket) # show that duplicates have been removed&#123;'orange', 'banana', 'pear', 'apple'&#125;&gt;&gt;&gt; a = set('abracadabra')&gt;&gt;&gt; b = set('alacazam')&gt;&gt;&gt; a # unique letters in a&#123;'a', 'r', 'b', 'c', 'd'&#125;&gt;&gt;&gt; a - b # letters in a but not in b&#123;'r', 'd', 'b'&#125;&gt;&gt;&gt; a | b # letters in either a or b&#123;'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'&#125;&gt;&gt;&gt; a &amp; b # letters in both a and b&#123;'a', 'c'&#125;&gt;&gt;&gt; a ^ b # letters in a or b but not both&#123;'r', 'd', 'b', 'm', 'z', 'l'&#125; Dictpython内置了dict，也就是以 key:value 的形式存储数据，具有极快的查找速度 dict在内部通过 hash 直接计算处 key 对用的 value 的地址，所以查找很快 key 的值不可变，所以不能用List来作为 key dict占用大量内存，这是肯定的，以空间换时间了 同一个字典不能有重复的key，新的会覆盖旧的 对一个字典执行 list(d.keys()) 将返回一个字典中所有关键字组成的无序列表（如果你想要排序，只需使用 sorted(d.keys()) ）。使用 in 关键字可以检查字典中是否存在某个关键字（指字典） 12345678910111213141516171819202122&gt;&gt;&gt; tel = &#123;'jack': 4098, 'sape': 4139&#125;&gt;&gt;&gt; tel['guido'] = 4127&gt;&gt;&gt; tel&#123;'sape': 4139, 'guido': 4127, 'jack': 4098&#125;&gt;&gt;&gt; tel['jack']4098&gt;&gt;&gt; del tel['sape']&gt;&gt;&gt; tel['irv'] = 4127&gt;&gt;&gt; tel&#123;'guido': 4127, 'irv': 4127, 'jack': 4098&#125;&gt;&gt;&gt; list(tel.keys())['irv', 'guido', 'jack']&gt;&gt;&gt; sorted(tel.keys())['guido', 'irv', 'jack']&gt;&gt;&gt; 'guido' in telTrue&gt;&gt;&gt; 'jack' not in telFalse&gt;&gt;&gt; d = &#123;&#125; #initialize&gt;&gt;&gt; dict(sape=4139, guido=4127, jack=4098) #可以直接利用关键字参数传入&#123;'sape': 4139, 'jack': 4098, 'guido': 4127&#125; TIPs 利用 del 语句来批量删除List 中的元素 元组只有一个元素时的定义 t=(0) 会有歧义，与 t=0 作用相同，所以用 t=(0,) 来消除冲突。 dict和set也有与列表生成式相似的生成式 12345&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;&#123;2: 4, 4: 16, 6: 36&#125;&gt;&gt;&gt; &#123;x for x in 'abracadabra' if x not in 'abc'&#125;&#123;'r', 'd'&#125; ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python-扬帆起航]]></title>
      <url>%2F2017%2F04%2F08%2Fpython-%E6%89%AC%E5%B8%86%E8%B5%B7%E8%88%AA%2F</url>
      <content type="text"><![CDATA[前言闲着无聊，重学python，记录总结。 Life is short,I use python. —From person I don’t konw [TOC] 学习环境linux和mac与生俱来，就比windows更适合windows。毕竟他们都是秉持着 一切皆对象 的原则。 python的安装无需多说，对于版本，我的看法是顺着时代，抛弃python2.x吧，虽然工作中很多库都建立在python2的依赖之上。但对于我们个人，直接学习python3.x是更聪明的选择。我的python版本是3.6 最好的学习资料还是推荐官方文档，有中文版 下面这张图是我偶然看见的，说明了python很多常用的语法 开发工具用过vim的小伙伴当然是不用多想，vim很适合开发python。 如果是喜欢IDE的童鞋，那就肯定是Pycharm了。jetbrains的软件都是非常赞的。当然python新手也推荐用这款软件，我之前也是一直在用，唯一的缺点就是启动时加载项目太慢了。 我自己使用的是sublime text3和相关的python package，sublime3界面比较好看，颜值吸引了我，专有的包管理器，扩展性不错。至于怎么配置，网上还是很多分享的。这里我只推荐两个package SublimeREPL ,这样就无需重复的保存，取cmd执行.py文件。在editor中可以直接编译运行py脚本 sublime3已经支持了函数声明跳转功能，但在项目文件变得杂多时，跳转结果并不准确，推荐ctags。这个大名鼎鼎的插件就不用多说了 上面三种方法对于初学者还是比较麻烦，尤其是第一和第三种。所以python3之后加入了idle代码解释器，下载之后，可以直接使用python自带的cmdline或者Idle的交互环境先学起来。 提示python解释器的注释 编码方式 1# -*- coding: utf-8 -*- 指定执行脚本的python解释器，必须在第一行，推荐下面的写法，让操作系统在env中寻找python解释器的路径 1#!/usr/bin/env python3 python中的字符串基本python支持单引号 &#39;str&#39; 和双引号 &quot;str&quot; 来修饰字符串，\ 用来转义。 123456789101112&gt;&gt;&gt; 'spam eggs' # single quotes'spam eggs'&gt;&gt;&gt; 'doesn\'t' # use \' to escape the single quote..."doesn't"&gt;&gt;&gt; "doesn't" # ...or use double quotes instead"doesn't"&gt;&gt;&gt; '"Yes," he said.''"Yes," he said.'&gt;&gt;&gt; "\"Yes,\" he said."'"Yes," he said.'&gt;&gt;&gt; '"Isn\'t," she said.''"Isn\'t," she said.' 可以看出来，单引号和双引号，相互之间的影响，是可以嵌套作用的。当然不推荐将简单的字符串写的如此复杂。 选用一种引号，再加上转义字符 \ 和 原始字符串 可以处理绝大部分的字符串。 原始字符串 ：r . r&#39;str&#39; 中的str默认不转义 12345&gt;&gt;&gt; print('C:\some\name') # here \n means newline!C:\someame&gt;&gt;&gt; print(r'C:\some\name') # note the r before the quoteC:\some\name 上面也可以用 print(&#39;C:\some\\name&#39;) 来避免冲突，但是明显不如使用 原始字符串 理解起来方便。 格式化和C语言类似，利用 % 来格式化输出，%s %d %f %x 分别用来代替字符串/整数/浮点数和十六进制整数,称为占位符。分不清楚的时候可以无需考虑直接使用 %s 1234&gt;&gt;&gt; 'Hello, %s' % 'world''Hello, world'&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)'Hi, Michael, you have $1000000.' 除了使用 % 来格式化，功能更多，使用起来更方便的是字符串自带的格式化函数 format ，具体用法看 str.format123456789101112131415161718192021222324252627282930313233343536# 位置参数print "&#123;0&#125; is &#123;1&#125; years old".format("Wilber", 28)print "&#123;&#125; is &#123;&#125; years old".format("Wilber", 28)print "Hi, &#123;0&#125;! &#123;0&#125; is &#123;1&#125; years old".format("Wilber", 28)# 关键字参数print "&#123;name&#125; is &#123;age&#125; years old".format(name = "Wilber", age = 28)# 下标参数li = ["Wilber", 28]print "&#123;0[0]&#125; is &#123;0[1]&#125; years old".format(li)# 填充与对齐# ^、&lt;、&gt;分别是居中、左对齐、右对齐，后面带宽度# :号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充print '&#123;:&gt;8&#125;'.format('3.14')print '&#123;:&lt;8&#125;'.format('3.14')print '&#123;:^8&#125;'.format('3.14')print '&#123;:0&gt;8&#125;'.format('3.14')print '&#123;:a&gt;8&#125;'.format('3.14')# 浮点数精度print '&#123;:.4f&#125;'.format(3.1415926)print '&#123;:0&gt;10.4f&#125;'.format(3.1415926)# 进制# b、d、o、x分别是二进制、十进制、八进制、十六进制print '&#123;:b&#125;'.format(11)print '&#123;:d&#125;'.format(11)print '&#123;:o&#125;'.format(11)print '&#123;:x&#125;'.format(11)print '&#123;:#x&#125;'.format(11)print '&#123;:#X&#125;'.format(11)# 千位分隔符print '&#123;:,&#125;'.format(15700000000) 多行字符串python使用三引号来处理多行字符串 12345print("""\Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to""") 字符串的高级特性 索引 字符串可以通过index访问，如 1str[0],str[1], ... str[len(str)-1] 还可以逆序访问 1str[-1],str[-2], ... 其中 str[len(str)-1] = str[-1] 切片 切片表达式 : str[a:b:c]从str字符串，按步长c，从下限a到上限b (不包含上限)，取出单个字符组成字符串 1234567&gt;&gt;&gt; word = 'abcdefghijklmn'&gt;&gt;&gt; word[0:3] # characters from position 0 (included) to 2 (excluded)'abc'&gt;&gt;&gt; word[5:10:2]'fhj'&gt;&gt;&gt; word[-10:-1:2]'ehikm' 当然不只是 字符串 这种数据类型才有 切片 特性，切片特性是可迭代对象共有的。 字符串是python中少有的不可变对象 python是动态语言，其中的不可变对象很少，比如tuple，字符串也是其中一种。 字符串的常用内置函数字符串是python的基本数据类型，但本质上，它是python封装的一个类对象，拥有着很多属性。 1234&gt;&gt;&gt;type(str)&lt;class 'type'&gt;&gt;&gt;&gt;dir(str)['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] dir(str) 以 list 的形式给出了字符串这个类的所有属性。常用的有： str.capitalize() 将字符串第一个元素大写 str.find(string,beg=0,end=len(str)) 检查str中是否还有string，找到返回起始索引 str.join(seq) 以str作为分隔，将seq中所有元素组成一个新的字符串 123&gt;&gt;&gt;word = 'Allenware'&gt;&gt;&gt;'-'.join(word)'A-l-l-e-n-w-a-r-e' str.split(str=&quot;&quot;,num=str.count(str)) 以 str 为分隔符切片 string，如果 num有指定值，则仅分隔 num 个子字符串 str.partition(str) 按string将str分为三段，返回一个包含三个元素的元组 123&gt;&gt;&gt;string='Allenware is very cool!'&gt;&gt;&gt;string.partition('is')('Allenware ', 'is', ' very cool!') str.strip() = str.lstrip() + str.rstrip() 截掉str左边右边空格 str.upper str.lower大小写转换]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[http协议]]></title>
      <url>%2F2017%2F04%2F08%2Fhttp%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[[TOC] Http DefinitionHTTP（Hypertext Transfer Protocol）就是超文本传输协议，它是现代互联网最重要也是最基本的协议。Http协议是无状态的、应用层协议，它是web开发的基础。 URL URL(Uniform Resource Locator) 地址用于描述一个网络上的资源。基本格式如下： 1234567891011schema://login@host[:port#]/path/..../[?query-string][#anchor] /* scheme: 协议名（如http,https,ftp） login: 登陆信息 host: 服务器IP/域名 port#:HTTP服务的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如http://www.cnblogs.com:8080 path: 资源路径 query-string: 发送给web服务器的数据 anchor: 锚 */ 举个例子： 123456789http://www.mywebsite.com/sj/test/test.aspx?name=sivergn&amp;x=true#stuff /* schema: http host: www.mywebsite.com path: /sj/test/test.aspx Query String: name=sviergn&amp;x=true Anchor: stuff */ URL的请求过程 当你在浏览器输入URLhttp://www.website.com的时候，浏览器发送一个Request去获取http://www.website.com的html。 服务器把Response发送回给浏览器。浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件。 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。当所有的文件都下载成功后， 网页就被显示出来了。 Request Method我们通过URL访问服务端获得资源，具体的操作由 http 协议的 request method 来定义。http/1.1 一共有八种操作： GET：向服务端发起获得资源的请求。GET 也是可以传递参数给服务端的，是将参数放在URL中携带到服务端，暴露在整篇网络环境中，很不安全。 POST：向指定的主机资源提交数据。一般都是向服务端提交表单数据进行处理。POST 提交的数据保存在http协议的body中。 PUT：向指定的主机资源上传最新的内容 DELETE：请求服务端删除Request-URL标识的资源 上面四种是用的最多的四种Method，有时候，我们将 PUT 和 DELETE 看作是POST的特殊实现。 HEAD：与GET方法类似，区别是只请求头部。用于测试和获得头部中的元数据 TRACE：回显请求 CONNECT：HTTP/1.1预留给一些代理服务器用，用于改变连接方式。 OPTIONS：测试服务端能支持的HTTP Method 对于Method常见的错误码： 405（Method Not Allowed） 是客户端的错误 501（Not Implemented） 是服务端的错误 GET实例： 1234GET /test/?id=11101&amp;name=Professional HTTP/1.1Host: www.test.comUser-Agent: Mozilla/5.0 (Windows; U;) Firefox/1.0.1Connection: Keep-Alive POST实例： 12345678POST / HTTP/1.1Host: www.test.com User-Agent: Mozilla/5.0 (Windows; U) Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivename=Professional&amp;id=11101 状态码通过URL和Method，客户端就可以发送一个完整的请求给服务端。当然服务端也会做出响应。状态码就是非常重要的一种响应，客户端通过状态码就可以了解服务端做出何种响应。HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别： 1XX 提示信息； 表示请求已被成功接收，告诉客户端可以继续发送下一个请求了，若如果已发送完毕可以忽略它。 2XX 成功 3XX 重定向； 要完成请求必须进行更进一步的处理 4XX 客户端错误；请求有语法错误或请求无法实现 5XX 服务器端错误；服务器未能实现合法的请求 常见的状态码1xx：Informational Messages这是 http/1.1 才支持的状态码，服务端可以发送一个 100-continue 告诉客户端继续发送消息，客户端如果已发送可以忽略。 2xx：成功告诉 client 接收到 Request 并成功处理，最常见的是 200 OK 202 Accepted: the request was accepted but may not include the resource in the response. This is useful for async processing on the server side. The server may choose to send information for monitoring. 204 No Content: there is no message body in the response. 205 Reset Content: indicates to the client to reset its document view. 206 Partial Content: indicates that the response only contains partial content. Additional headers indicate the exact range and content expiration information. 3xx：Redirection这个状态代表客户端需要重定向到其他URL获取资源，新的URL在Response中，浏览器会自动向新的URL发起Request 301 请永久到新的URL获取资源 303 资源暂时位于新的URL，新的URL记在 Location Response Header 中 304 告诉client请求的资源没有更新，可以直接使用client缓存中的备份。（当然有没有更新是靠头部中的标识进行hash计算的） 4xx：Client Error当客户端发出一个 bad request 或者请求无效资源时，server端会认为时client出错了。最常见的是 404 Not Found 。404 表示资源无效，在服务端上不存在。 400 Bad Request：请求语法错误 401 Unauthorized： 未经授权。可以通过带有 Unauthorized 的头部再次发起请求。还是401错误应该可以推断是没有证书。 403 Forbidden：服务器收到请求，但是拒绝提供服务 405 Method Not Allowed：request line中的method不合法 409 Conflict：冲突了。通常出现在多人协作时。 5xx：Server Error用于来表示server端出现了故障。最常见的是 500 Internal Server Error 服务器发生不可预期的错误。 501 Not Implemented：服务器不支持此方法 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常 Http消息结构消息格式http协议对 Request 和 Response 两种消息定义了下面的格式： 1234567message = &lt;start-line&gt; *(&lt;message-header&gt;) CRLF [&lt;message-body&gt;]&lt;start-line&gt; = Request-Line | Status-Line&lt;message-header&gt; = Field-Name ':' Field-Value 从上面定义我们可以看到，Http的Request和Response消息都是由三部分组成： 1231. start-line 开始行 2. header 消息头 3. body 消息体 对于start-line，又分为： 121. Request-Line : 'METHOD/path-to-resource http-version'2. Response-Line : 'http-version status-code message' 对于Headers则有如下几种： 123451. general headers2. entity headers3. request or response headers a. request specific headers. b. response specific headers. Request12GET http://www.google.com/ HTTP/1.1Host:www.google.com 用表格来表示： Request Line METHOD/path-to-resource HTTP/version-number Request Header Field1 : Value Request Header Field2 : Value 空行 空行 Request Body data(optional) Request Line／请求行 Method ：请求方法，如GET/POST path-to-resource ：所请求的资源在web服务器上的位置 HTTP/version-number：HTTP协议版本号。 Request Header，记录请求行以外的重要信息。 Request Body，携带提交给web服务器的数据。使用GET方法时，为空。 注意，Body和Header之间空一行。 Response Response Line HTTP/version-number status-code message Response Header Field1 : Value Response Header Field2 : Value 空行 空行 Response Body data(optional) Response Line／响应行 HTTP/version-number ：HTTP协议版本号 status-code ：状态码，反应服务器处理是否正常，告知出现的错误 message ：状态消息，同状态码对应。 Response Header / 响应头 ：记录响应体数据的相关信息。 Response Body / 响应体 ：携带需要向web服务器发送的数据。使用GET方法时，为空。 TIPs 对于GET方法，例如Http://localhost/login.php?username=aa&amp;password=1234 ，很明显能辩认出 ? 后就是 query-string ，易被网络爬虫爬取信息。 对于POST ，则会将提交的数据保存到HTTP的BODY中，比如上面的 username=aa&amp;password=1234 Reference 云栖社区 Http协议详解 HTTP协议详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为什么不用Markdown写设计文档?]]></title>
      <url>%2F2017%2F04%2F03%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8Markdown%E5%86%99%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[why write this blog之前只有在用一些笔记软件的时候偶尔接触过markdown这个东西，只知道是一种轻型的标记语言。现在工作还有各方面的需要，必须抽出一些时间系统的学习一下markdown。当然并不研究markdown的渲染原理，只学习用法。 [TOC] Markdown简介wiki上的介绍 Markdown is a lightweight markup language with plain text formatting syntax. It’s designed so that it can be converted to HTML and many other formats using a tool by the same name. 这么看，markdown的设计初衷肯定不是面向码农了，受众应该是经常写文档，写邮件的办公室一族了。 Markdown提供一套规定的语法，让写出的文档经过markdown processer的处理，转化为html，从而格式化你的.md文件。 当然，到了现在，Markdown的使用范围和影响已经渗透到各个行业，许多人日常的工作经常需要和它打交道。Github天生对md文件的支持，国内博客如简书也流行起markdown的方式来写博客。而抽出一小时左右的时间就能学会并使用它，还是非常值得，希望这篇blog会对你们有所帮助。 Editor工欲善其事，必先利其器。这里我推荐typero 下面是我写这篇博客时的截图 功能齐备 mac/windows的跨平台支持 界面清爽，cold style markdown的语法建和快捷键的绑定 准备好之后，开始markdown的学习。 区块元素标题标题用 # 来提示markdown引出标题，一共有六级标题，字体从大到小。合理的在一篇文章中使用标题，可以通过 [toc] 自动生成目录，而且让你的文章层次更加清楚。 1234# header1## header2...####### header6 header效果： 引用使用 &gt; 符号，引用的范围很广，通用解释、官方定义、他人专利都推荐用引用格式。 1&gt; 输入引用的内容 blockquotes效果： 列表un-orded list使用 - 来创建无序列表，+ * 具有相同的作用。 12345## programming language- c++- pyhton- go- java orded list有序列表，使用 1. item1 来创建，可以不按顺序，markdown语法解析器会自动识别 1234## popular1. javascipt2. pyhthon 3. java task list也就是html中的复选框，使用 - [] 来创建，默认不选中，- [x] 为默认选中的复选框 123- [] option1- [] option2- [x] options 效果如下： [ ] option1 [ ] option2 [x] option3 code block很多博客和笔记软件都支持加入代码块这个功能，可以保持代码的原貌。在typero中是使用 ` 来加入代码块，其他editor可能略有不同。1234```pythonfor a in list func(a) linksmarkdown支持两种link方式，inline和reference。两种方式都是用 [ ] 来修饰需要链接的对象。 inline links 在需要链接的对象后面，用括号加上links即可。用符号表示就是 [object] 后面加上 (links &quot;title&quot;) title是可选项。如果链接访问的本地主机的资源，可以用相对路径代替url 123[Baidu](http://baidu.com/ "baidu") is a famous company.See my [About](/about/) page for details. 效果： Baidu is a famous company. See my About page for details. reference links 与inline不同的是，它不直接指明链接的地址。而是在 [object] 后面跟上一个 [identifier] ，然后在文件的合适地方，给identifier定义一个links，这样object就能通过唯一的identifier找到自己的links。如果 [identifier] 为空，则默认和 [object] 同名 123[Tencent][qq] has been the best internet company in Asia.[qq]: http://allenware.github.io "Allenware" 效果： Tencent has been the best internet company in Asia. imagesimages的用法和links基本相似，只是加了一个 ! 在前面 inline式的语法如下： 123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg "Optional title") reference式的语法如下： 123![Alt text][id][id]: url/to/image "Optional title attribute" table创建表格，使用|header1|header2|...|headern| 来创建n列的表格，自动生成表格之后可以调节表格大小。 id name score 1 Allen 100 2 James 90 3 Victoria 95 Footnotes创建脚注 123You can create footnotes like this[^footnote].[^footnote]: Here is the *text* of the **footnote**. 效果： You can create footnotes like this[^footnote]. [^footnote]: Here is the text of the footnote. TIPs 需要注意markdown中有意义的符号，在写文章时可能会出现冲突，比如下面这个例子 11994. the year i was born 我的目的只是将它作为普通语句输入，解释markdown的语法解析器会把它误认为列表的提示键，这种情况需要引入 \ 转义符，正确用法如下 11994\. the year i was born 强调语法，使用**word** 来加粗，*word* 使字体变斜 _ 和 * 是同样的作用 TOC 用法，使用 [toc] 来生成目录，前面已介绍 下划线，可以使用下面的符号生成 1234---------********* 简短的代码引用可以用code就可以，比如 printf 是输出语句 插入image稍微麻烦一些，本地图片很方便，其他的可以用七牛云图片存储。 :smile :happy: 可以输入emoji ​比如：:open_hands: :clap: :haha: ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F02%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
