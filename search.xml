<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[python - OOP进阶]]></title>
      <url>%2F2017%2F04%2F23%2Fpython-OOP%E8%BF%9B%E9%98%B6%2F</url>
      <content type="text"><![CDATA[前言python的class有很多高级特性，除了OOP的三大特性，还在设计模式，自定制类和内存优化等都下了很多功夫。记载一些常用的类特性。 给实例动态绑定方法不是一定要在定义的时候就要给class写出所有的方法，可以在程序中动态的为实例绑定新的方法。 12345678def func(): print('hahaha')class A(object): passa = A()a.value = 1from types import MethodTypea.hahaha = MethodType(func,a) 给类绑定方法的话比较简单，直接绑定就可以，没必要使MethodType去绑定 slots我们知道，创建一个类时，为这个类创建了一个对象，这个类在实例化后会产生一个 __dict__，这个字典的目的是为了存储实例中的各种属性，你为实例添加变量或者函数都会记录在这个字典中。但是如果在类中，声明了__slots__ ，实例化时不会去创建字典，只会创建一个给定大小的数组用来存储__slots__中指定的属性。 12345678class Person(object): __slots__ = ('name','age')p = Person()p.name = "Allenware"p.age = 22p.country = 'China' #报错 __slots__ 只对当前类有效，对继承的子类没有作用。子类也做此声明，则父类和子类本身的__slot__中声明的名称同时有效。 当然，__slots__ 虽然有着访问限制的作用，但是python中的访问限制全靠自觉，这个特性最主要的用法是在为一个类创建大量实例时，事先知道属性范围，使用__slots__可以节省大量的内存。原因就是开始的原因，定长数组是要比字典省内存的多的。 @property这个语法糖，设计出来是为了让封装更加的间接。面向对象基础中有这个例子 12345678910111213141516171819202122232425262728class Student(object): kind = 'school' def __init__(self,name,age): self.name = name self.age = age def output(self): print(self.name) print(self.age) def getage(self): return self.age def setage(self,age): if age is int: self.age = age else: raise ValueError('Not int')Allen = Student('Allen','22')Peter = Student('Peter','23')print(Allen.kind)print(Peter.kind)print(Allen.name,Allen.age)print(Peter.name,Peter.age) 在这个例子中，想要给实例设置年龄的话，必须使用 instance.setage()，虽然可以通过这个方法来检查参数或者添加其他功能，但是不如 instance.age = age 直接绑定来的简单粗暴。而且有时候会导致代码可读性降低。 这时候可以利用@property来改善代码。 12345678910111213141516171819202122232425class Student(object): kind = 'school' def __init__(self,name,age): self.name = name self.age = age #这里使用self._age会避开装饰器的作用 @property def age(self): return self._age @age.setter def age(self,age): if type(age) is int: self._age = age else: raise ValueError('Not int')Allen = Student('Allen',22)Peter = Student('Peter',23)Allen.age = 23print(Allen.age)Allen.age = 'a' 最后一句的绑定是会报错的，这就是@property 的作用，给属性绑定值的时候自动调用了age的set函数。在你原来的setage()函数上加上@age.setter语法糖，初次之外，还有@age.deleter这个用于删除时的语法糖。不过这三个语法糖紧跟的函数必须是同名的。默认的@property其实就起着get的作用。 上面的例子可以换一种写法 1234567891011121314151617181920class Student(object): kind = 'school' def __init__(self,name,age): self.name = name self.set_age(age) def get_age(self): return self._age def set_age(self,age): if type(age) is int: self._age = age else: raise ValueError('Not int') def del_age(self): raise AttributeError('Cannot delete age!') age = property(get_age,set_age,del_age) 这个作用是跟之前的写法一样的，通过这个写法就能看出一点@property的原理了。property相当于一个类，为你指定的attribute实例化一个property对象，为get、set、del绑定好对应的三个方法，在你对attribute进行这三个操作时，会触发事先绑定好的方法，这牵扯到了装饰器的原理用法。所以用第一种写法可读性更高。 在用@property 要注意使用时的情景，并不是所有情况都适用，如果你有想要管理的属性，那就是使用 @property 的时机。 __str__12345678class Person(object): def __str__(self): return 'Person Object' __repr__ = __str__ pan = Person()print(pan) 这样，print(instance) 的输出就是和 __str__ 函数中指定的输出了。看起来很简单的小功能，其实是很实用的。可以在 __str__ 中加入你想要的属性信息，很方便调试。 上下文管理之前提到过with语句，让一个类支持with特性的话，需要自定义__enter__()和__exit__()方法 12345678910111213141516171819from socket import socket, AF_INET, SOCK_STREAMclass LazyConnection: def __init__(self, address, family=AF_INET, type=SOCK_STREAM): self.address = address self.family = family self.type = type self.sock = None def __enter__(self): if self.sock is not None: raise RuntimeError('Already connected') self.sock = socket(self.family, self.type) self.sock.connect(self.address) return self.sock def __exit__(self, exc_ty, exc_val, tb): #异常值、异常类型、回溯信息 self.sock.close() self.sock = None 这个类在实例化的时候并不会去创建连接，只有在使用with时，连接的连接和关闭都是自动完成的，所以调用完with之后，可以直接send或者recv进行数据交互了。 上下文管理在资源管理中用的非常广，比较文件、网络socket，还有上次说的线程锁。可以在 __exit__ 中release来保证锁的释放。 枚举类1234567from eunm import EnumAnimal = Enum('Animal','cat dog ant')class Animal(Enum): cat = 1 dog = 2 ant = 3 __type__type() 不仅仅用于检测对象的类型，也可以用于创建class对象，接收三个参数 class的名称 继承的父类，用元组 属性，字典形式 拥有了type() ，我们可以动态的去创建类，让一个函数返回新建的类。结合上面的枚举类，自己用type()实现一个枚举类 1234567891011def enum(**enums): return type('Enum', (), enums) Numbers = enum(ONE=1, TWO=2, THREE='three')#人性化一点，可以接受列表的输入def enum(*sequential, **named): enums = dict(zip(sequential, range(len(sequential))), **named) return type('Enum', (), enums) Numbers = enum('ZERO', 'ONE', 'TWO') super()super用来调用父类的方法，一般是用来保证在本身初始化的时候，父类也被正确的初始化。 12345678class A: def __init__(self): self.x = 0class B(A): def __init__(self): super().__init__() self.y = 1 这个可以结合访问限制的 __ 来使用，因为之前说过，双下划线的命名方式的目的就是为了防止父类的属性被子类不小心覆盖了。我们可以在子类中找不到对应属性的时候，使用super()去父类中寻找。 123456789101112class Test(Father): def __init__(self, obj): self._obj = obj def __getattr__(self, name): return getattr(self._obj, name) def __setattr__(self, name, value): if name.startswith('__'): super().__setattr__(name, value) else: setattr(self._obj, name, value) super() 用于多继承时，会避免重复调用某一个父类的初始化方法。而如果直接使用父类的类名来调用初始化方法，则会重复调用。当然super是需要慎用的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pyhon - OS相关]]></title>
      <url>%2F2017%2F04%2F23%2Fpyhon-OS%E7%9B%B8%E5%85%B3%2F</url>
      <content type="text"><![CDATA[前言 我是偏后台开发的coder，学到python的这里时尤其的关注。操作系统的相关接口在python是不是比linux C中要简洁的多。OS的概念不说了，这次笔记集中关注python中多进程、多线程、高并发、加锁同步、进程间通信等实现。 Definition进程(process)，在我的理解中，就是一个任务，是一段运行的程序。后台的童鞋应该知道其本质就是一个task_struct结构体，里面记载着程序运行需要的所有资源和他自身的信息。当他获得运行所需的内存、CPU资源等，也就是成为了一个running状态的进程。 可以把进程理解为一个任务，那线程就是完成这个任务的执行流。线程是CPU调度的最小粒度。通常来说，现在的项目中，至少我接触的，一个进程中都包括着不止一个的线程。毕竟现在的OS都是SMP的，充分利用多核心提高程序效率应该是每个coder敲键盘时需要优先考虑的。 多进程linux的内核向外提供了 fork() 这个系统调用来创建一个本进程的拷贝，当然往往fork()后都跟着 exec() 族系统调用，我们创建一个进程一般都是为了执行其他的代码程序。 python的 os 模块封装了很多常用的系统调用，可以说是python中最常用的一个库了。举个栗子： 123456789import osprint('Process (%s) start...' % os.getpid())pid = os.fork()if pid == 0: print('Child process (%s).' % os.getpid())else: print('Parent process (%s).' % pid) fork() 会返回两个结果，父进程返回一个大于0的无符号数，子进程返回0。 我们都知道socket()是有好几个步骤的，而对于web服务器，每天每时每分都有着成千上万的访问请求。如果是一个进程向外提供服务，那就是这个进程为第一个用户从创建socket到关闭，再为下一个用户提供服务。用户时排着队接受服务的，显然不符合逻辑。 拿Apache举个栗子，它是多进程架构服务器的代表。 运行主程序，只负责server端socket的listen()和 accept()，当然主进程是一个守护进程 每当一个用户请求服务，就会调用fork()，在子程序中接受数据，read()或者write()，然后提供服务直至关闭 主进程还是要负责回收结束的子进程资源的 伪代码如下： 1234567891011import osserver_fd = socket()bind(server_fd,ip,port)listen(server_fd,MAX_PROCESS)While Online: connfd = accpet(server_fd) for each connfd: os.fork() // TODOclose(server_fd) 上面这段程序只适用linux平台，windows平台创建进程的方式并不是 fork() 调用。python中提供了multiprocesssing模块来兼容windows，比起fork()，代码的语义更好理解一些 1234567891011121314from multiprocessing import Processimport osdef run_proc(name): print('Child process %s (%s)...' % (name, os.getpid()))if __name__=='__main__': print('Parent process %s.' % os.getpid()) #创建Process实例 p = Process(target=run_proc, args=('test',)) print('Child process will start.') p.start() p.join() print('Child process end.') 这里的join语义和linux平台的多线程中的join语义很像，但效果其实是linux平台的wait 有时候需要进程池，multiprocessing 也直接提供了pool用于创建。 1234pool.apply(func,params) 是单进程阻塞模式pool.apply_async(func,params,callback) 是多进程异步模式pool.map(func,iter) 用于可迭代结构，阻塞式调用pool.map_async(func,iter,callback) 一般情况下，还是把进程数控制成和CPU核数相同。pool结束调用pool.join()回收进程资源时，需要先pool.close() 上面提到过，创建一个新进程的原因往往是为了加载新的代码，去执行新的任务。所以python封装了fork()和之后的exec族，提供subprocess模块，直接操作新的子进程。这个包，一般是用来执行外部的命令或者程序如shell命令，和os.system()类似。 12345678910import subprocessr = subprocess.call(['ls','-l']) #阻塞r = subprocess.call('ls -l',shell = True)r = subprocess.check_call(['ls','-l']) #returncode不为0则raise CalledProcessError异常r = subprocess.check_output('ls -l',shell=True)r = subprocess.Popen(['ls','-l']) #非阻塞，需主动waitr = subprocess.Popen(['ls','-l'],stdin=child1.stdout,stdout=subprocess.PIPE, stderr=subprocess.PIPE) #设置标准输入输出出错的句柄out,err = r.communicate() #继续输入，或者用来获得返回的元组(stdoutdata,stderrdata) 手动继续输入的例子： 1234567import subprocessprint('$ python')p = subprocess.Popen(['python'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)output, err = p.communicate(b"print('Hello,world')")print(output.decode('utf-8'))print('Exit code:', p.returncode) 进程间通信用multiprocessing的Queue或者Pipe来帮助实现，类似linux中的Pipe，打开一条管道，一个进程往里面扔数据，一个从另一头捡数据。python中的Pipe是全双工管道，既可以读也可以写。可以通过Pipe(duplex=False)创建半双工管道。 12345678910from multiprocessing import Pipe,Queue#实例q = Queue()p = Pipe()#写入数据q.put(value)p[0].send(value)#读数据q.get()p[1].recv() 分别举个例子，用Queue 1234567891011121314151617181920212223242526from multiprocessing import Process, Queueimport os, time, randomdef write(q): print('Process to write: %s' % os.getpid()) for value in ['A','B', 'C']: print('Put %s to queue...' % value) q.put(value) time.sleep(random.random())def read(q): print('Process to read: %s' % os.getpid()) while True: value = q.get(True) time.sleep(random.random()) print('Get %s from queue.' % value)if __name__=='__main__': q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) pw.start() pr.start() pw.join() pr.terminate() 用Pipe： 123456789101112131415161718192021222324252627from multiprocessing import Process, Pipeimport os, time, randomdef write(q): print('Process to write: %s' % os.getpid()) for value in ['A','B', 'C']: print('Put %s to pipe...' % value) q.send(value) time.sleep(random.random())def read(q): print('Process to read: %s' % os.getpid()) while True: value = q.recv() time.sleep(random.random()) print('Get %s from pipe.' % value)if __name__=='__main__': p = Pipe() pw = Process(target=write, args=(p[0],)) pr = Process(target=read, args=(p[1],)) pw.start() pr.start() pw.join() time.sleep(2) pr.terminate() 多线程有人会有疑问，问什么要在进程中开多个线程，多创建几个进程一起干活不就行了。其实这样是可以的，只不过进程这个单位有点大，比较占用资源，创建的时候开销比较大(尤其在windows系统下)，进程多了CPU调度起来，在进程间切换也是非常耗时的。还有多任务协同合作时，需要数据交换，进程间通信也是开销，而一个进程中的线程是共享进程的内存空间的，可以直接交互。所以现在多线程的程序更加常见。 不过多线程也是有弊端的，协同合作的多线程，有一个挂了，会影响到所有的其他线程，也就代表这个任务是做不下去了。进程因为有着独立的地址空间，所以一个进程死了对其他进程的影响可以说很小。 python中提供了threading模块为多线程服务,threading.current_thread()返回当前线程，主线程名为MainThread 12345import threadingthread = threading.Thread(target=func,args=())thread.start()thread.join() 多线程编程，最重要的就是同步和互斥，也就是各种锁的用法。为什么要用锁，后台的童鞋应该都懂，现在的SMP操作系统都是抢占式内核，也就是即使你不同的核共同工作时，很幸运的没有改乱一个共享变量，当然这就不可能了。当你的CPU时间片到时间了，或者需要内存或者IO资源，你被踢出了CPU的工作队列，你必须得在走的时候给你的资源把锁加上，下次再来接着做。线程同步的重点的是对共享资源的判断，和选择合适的锁。也就是对什么资源加锁和用什么锁。 不过在python中很遗憾，多线程存在着天生的缺陷，因为有着GIL的存在，这是python解释器的设计缺陷。导致python程序在被解释时，只能有一个线程。不过，对于IO密集型的程序，多线程的设计还是很有帮助的。比如爬虫 最常用的锁，类似 mutex 条件变量，threading.Condition()会包含一个Lock对象，因为这两者一般都是配合使用的。 信号量，threading.Semaphore() 1234567891011121314151617import threadinglock = threading.Lock()lock.acquire()lock.realease() #配合try...finally保证最后释放掉锁，防止死锁cond = threading.Condition()cond.wait()cond.notify() cond.notify_all()sem = threading.Semaphore(NUM)sem.acquire()sem.realease()event = threading.Event() #相当于没有lock的condevent.set(True)event.clear() 假设以下的情况 1234567891011thread_func(params): web_res = params def func1(web_res): http = web_res.http TODO def func2(web_res): data = web_res.data TODO def func3(web_res): user = web_res.user TODO 在一个线程中，又存在多个子线程或者函数时，需要把一个参数都传给它们时。可以通过唯一的id来区分出从全局变量自己的局部变量时。可以用ThreadLocal实现 123456789import threading student = threading.local()def func(name): person = student.name #需要之前关联过p1 = threading.Thread(target=func,argc='A')p1 = threading.Thread(target=func,argc='B') 通过ThredLocal免去了我们亲自去字典中存取。通常用于web开发中的为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等。 分布式进程分布式是为了在横向上提升整个系统的负载能力。python中multiprocessing模块中的manage子模块支持把多进程分布到不同的机器上。当然肯定存在一个master进程来负责任务的调度。依赖manage子模块，可以很轻松的写出分布式程序。 比如爬虫，想要爬下豆瓣或者知乎这样网站的全部数据，用单机估计得花费好几年。可以把需要爬的网站的所有URL放在一个Queue中，master进程负责Queue的管理，可以将很多设备与master进程所在的设备建立联系，爬虫开始获取URL时，都从主机器获取。这样就能保证协同不冲突的合作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python - 面向对象基础]]></title>
      <url>%2F2017%2F04%2F16%2Fpython-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[[TOC] 前言OOP的概念就不说了，想必都很了解了。 Oop的三大特点：继承、封装和多态。python作为动态语言的一种，不仅实现了静态语言的这三个特点的常规功能，也额外拓展了很多面向对象的新特性。 new-style classpython2前几个版本的时候，python还在用旧式类，现在已经基本都是新式类了。两者写法上的区别 12class Myclass:class Myclass(object): 新式类是直接或间接继承自object基类的，如果没有可以明显继承的父类，那就在括号中加上object来声明这是个新式类。相比旧式类，新式类最大的改动就是在多继承时，到父类寻找本类中不存在的属性时，从以前的深度优先搜索改为了广度优先搜索。这样改的原因，也是跟新式类的类继承的层级关系有关。对于Class A(B,C)，如果仍用广度优先搜索，会从B一直向上递归搜索到object基类，这样在继承较多类时，每次都会重复的去访问object基类，很降低效率。 初次之外，新式类也增加一些原来旧式类没有的新属性，比如__slots__ __setattr__ __class__等等很实用的属性。 封装在这里需要结合之前的python-命名空间和作用域那篇文章来解释一下类对象的生效原理。 类在定义时，会在当前的局部作用域创建一个命名空间，也就是类名到类对象的映射，类中的属性都要通过类名作为前缀来引用。 对于类中定义的变量，由类变量和实例变量的分别。类变量对于所有实例都可见，而单独一个实例中的变量只对自己可见。 12345678910111213class Myclass(object): a = 1 def __init__(self,b): self.b = bA = Myclass(2)B = Myclass(3)A.a #1B.a #1A.a = 100B.a #100A.b #2B.b #3 类中定义的函数，实例化对象中对用的函数我们都称为方法。方法与普通函数的区别就是，方法的第一个参数都是 self ，比如 a.f(param) 这个方法的本质，就是将实例化出来的 a 对象和方法参数组装成新的参数列表，来调用类中的函数 A.f(a,param) 由__word__ 声明的属性，都是特殊变量或者方法。一般情况下，我么都用不上。上面例子的 __init__ 的作用是在类实例化时，对实例进行初始化的特殊方法，相当于C++中的构造函数。实际中，往往通过这个方法来给实例化传递参数。 看下面这个类： 12345678910111213141516171819202122232425class Student(object): """ test class """ kind = 'school' def __init__(self,name,age): self.name = name self.age = age def output(self): print(self.name) print(self.age) def setage(self,age): self.age = ageAllen = Student('Allen','22')Peter = Student('Peter','23')print(Allen.kind)print(Peter.kind)print(Allen.name,Allen.age)print(Peter.name,Peter.age) 对于 Student 这个类，实例化了 Allen 和 Peter 两个对象，拥有各自的 name age 属性和共有的 kind 属性。封装的好处就是不用在类外关心具体的方法实现，抽象出操作方法提供出去就可以。比如上个例子中的 output 方法，也可以通过 setage 来重新设置实例对象的 age 属性。 当然，在C++中有private和public变量的区分，目的也是为了保护某些比较重要的变量不被随意或者无意的修改掉。python 在这方面也提供了访问限制。 在类属性前，添加单下划线 _ 来声明这个变量是private变量。如果你看到类属性带有下划线，正确的做法是不要去使用它。但这全靠自觉！加载其他模块时，不会去加载带 _ 声明的变量和方法。python并不会真的去隐藏掉属性，都是靠着这些约定俗成的规定来避免麻烦。 当继承关系比较深之后，对新类的属性命名会很令人头疼。因为你要考虑到新的命名会覆盖掉不知道父类中的哪个属性。遇到这种情况，可以在属性前加上双下划线 __ ，python解释器会将此类变量解析为 _classname__word，这样前缀有着不同类的命名会避免覆盖父类属性的麻烦。比如上面的例子，将所有的self.name 改为 self.__name ，再通过 Allen.__name 去访问时，是会报错的，因为已经被解释器改掉了变量名。当然可以在类内，添加 getage() 方法来访问。类内属性的命名还是可以通过 self.__name 来访问的。(虽然在类外，也可以通过Allen._Allen__name来强行访问name属性，但很不推荐！后果自负) 继承继承很简单，在class Myclass() 括号中，加上需要继承的类就可以，与java的单一继承不同，python是允许多继承的！也就是class A(B,C) 这样类A就同时继承了类B和类C。当然这边有个问题，当在调用类A中没有的属性时，是去哪个父类寻找？具体可以看这篇文章,直接看例子： 12345678910111213141516171819202122class A: def __init__(self): pass def save(self): print("This is from A")class B(A): def __init__(self): passclass C(A): def __init__(self): pass def save(self): print("This is from C")class D(B,C): def __init__(self): passfun = D()fun.save() 很简单的小例子，如果来自A那就是深度优先搜索，来自C的话就是广度优先搜索。当然重写父类已有的方法会覆盖掉原有的实现，这就可以通过上面提到的双下划线命名机制来避免冲突。子类可以通过 super() 来调用父类中的方法。 可以通过 isinstance(object,class) 来判断对象是否是某类的实例。也可以通过issubclass(class1,class2)来判断class1是否是class2的子类 多态python中的多态很强大，它支持了 duck typing。先看具有继承关系的类中的多态： 1234567891011121314151617181920212223class Human(object): def out(self): print("I live on Earth")class Asian(Human): def out(self): print('I live in Asia')class Chinese(Asian): def out(self): print('I live in China')def run(person): person.out()A = Human()B = Asian()C = Chinese()run(A)run(B)run(C) 结果： 123I live on EarthI live in AsiaI live in China 只定义了 run(person)这一个函数，却可以调用三个类中的方法，这就是多态的魅力。不关心传入对象的具体信息，只需要你实现了out方法，就是可以被调用的。当然对于有继承关系的类，只要你的父类中有实现，就可以被调用。 对于静态语言，函数在定义时就已经确定了，所以多态的威力还限制在只有继承关系的类中。对于python这种动态语言，只要你定义的对象拥有out()方法，甚至不需要你是函数定义参数的子类，就可以被调用。比如在上面例子中加入 123class animals(object): def out(self): print('I am not person.') 输出 1234I live on EarthI live in AsiaI live in ChinaI am not person. animals并不是Humen的子类,只是因为实现了out()方法，就可以被run()函数调用。这就是著名的鸭子类型。动态语言中，并不要求严格的继承关系，只要这个对象 看起来像鸭子，走起路像鸭子，那就把它看成一只鸭子！ 接触过网络编程的同学，应该很容易能联想到网络编程中也有相关的实现。比如读写文件，你会调用 open() read() write() 这些方法来操作file，但是还有很多特殊文件都可以通过这三个api来调用，比如socket描述符、pipe管道等等。这些东西都是长的像文件，那就可以被这些api调用！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python-命名空间和作用域]]></title>
      <url>%2F2017%2F04%2F15%2Fpython-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[[TOC] 前言前段时间写脚本的时候，在调用函数的时候，一直在想在python中函数的参数是传值还是传引用？先看一下下面两个例子 12345678a = 1def setvalue(arg): arg = 100 print(arg) setvalue(a)print(a) 这个例子中，会发现最后打印出的 a 仍然是 1 ，看起来像是传值调用。再看另一个例子：12345678a = [1]def setvalue(arg): arg[0] = 100 print(arg[0])setvalue(a)print(a[0]) 这个例子的结果 a 中的数值已经修改成了 100，这样看又是传引用。熟悉C语言的可能在这里会说，这里传的是地址，所以修改有效。当然可以这么理解，但是在 python 中，对待变量与赋值需要换一个角度去理解。这也是我学python遇到的第一个难点，涉及到了python的namespace和scope，想要学好python是必须要弄懂的。 一切皆对象python 最大的特点也是最核心的思想，以前就提到过就是： 一切皆对象 。在说 namespace 和 scope 之前，先说一下python中给变量赋值的原理。1234a = 1 #1a = 2 #2b = a #3del a #4 在 python 中，所有的int，string，list，dict，函数和类等等等等，我们都把它看成是一个对象。 比如上面的 1 的意思，正确的理解是 a 引用了 1 这个对象或者将 a 绑定给了 1 ，，而不是将 1 这个值赋给 a 。深入点说，就是 1 这个对象的所有属性包括值都只存在自身，a 只是在 1 上打了个标签，并没有将实际的数据拷贝到自身！你只是可以通过命名 a 能够访问到 1 这个对象的信息。而如果执行了上面语句 4 ，含义就是在对象上删掉 a 这个标签，在通过 a 访问时就会报a命名未定义的错误。 语句 2 会删除掉a在1上的标签，触发python的垃圾回收机制，然后语句 3 会将 b 也绑定到2这个对象上。 再回到最先的例子中，用刚谈到的对象概念去重新理解。例子1中，在调用函数 setvalue 时，只是将参数 arg 也绑定到 a 所引用的对象 1，但是在 setvalue 函数中，删除掉了 arg 在对象 1 上的标签，重新绑定到了对象 100 上，对 a 是没有影响的。在例子2中，arg 也绑定到 [0] 这个列表对象上。函数中的操作仍然是对 a[0] 这个对象的操作，所以结果肯定是同时影响到已经绑定到 a[0] 上的所有变量的。 最后回到开始的问题，到底是传值还是传引用呢？其实都不是，python中可以理解为传对象。 Consider消化完上面的内容之后，再看一个例子1234567a = 1def setvalue(): a = 100 setvalue()print(a) 简单的加一句声明之后12345678a = 1def setvalue(): global a a = 100 setvalue()print(a) 简单的解释一下，因为在第一个例子中，函数中的 a 是局部变量，作用域只在函数内，所以不影响函数外的命名空间。第二个例子中，使用了 global 关键字，作用是将函数内对 a 的操作影响扩展到全局，所以函数外的结果收到了影响。 NamespaceDefinition命名空间的定义：变量到对象的映射集合。一般都是通过字典来实现的。主要可以分为三类： 内置命名空间 函数的本地命名空间 模块的全局命名空间 对于模块的全局命名空间，因为有着模块名的前缀，所以互相是没有影响的。比如模块A和B都有c变量，那么通过A.c和B.c来使用是不冲突的。这三种命名空间也有着自己的生存周期，除了第二个函数的本地命名空间生存周期只在函数的调用开始到结束，其他两个的生存周期都是可以看做持续到解释器退出的。 作用命名空间的作用：程序在直接访问变量时，会在当前的命名空间内查找。 比如：你在程序内执行 x = A 时，就会在当前的命名空间增加x到A的映射。如果使用del x 会删除掉命名空间中x的命名。 这里稍微拓展一下，import导入模块的本质，就是将其他模块的类、函数、变量等对象加入到程序的命名空间。再谈的深一点，python 中类的继承也是通过命名空间来实现的！这个下次笔记再说。。跑偏了 Scope作用域 就是一个 Python 程序可以直接访问命名空间的正文区域。也可以理解是多种层级命名空间的叠加作用。在一个python程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。可以具体分为以下四个作用域： Local(innermost)包含局部变量，比如一个函数/方法内部。 Enclosing包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，内层函数可能搜索外层函数的namespace，但该namespace对内层函数而言既非局部也非全局。 Global(next-to-last)当前脚本的最外层，比如当前模块的全局变量。 Built-in(outtermost)Python builtin 模块。包含了内建的变量/关键字等。 一个命名的作用域在它初次定义的时候确定，如果在当前作用域找不到命名时，会到外层作用域中寻找相应的命名，最后回到全局作用域和内置作用域中寻找。也就是按照LEGB的顺序来寻找一个命名对应的对象。 概念很抽象，具体来看代码 作用域如何生效的例子：12345678910def test(): b = 200 def test2(): b = 100 print(b) test2() print(b)b = 300print(b) 函数 test2() 中访问b时，在本地作用域率先找到 b=100 这条语句，所以由100这个对象起作用。在 test() 中，它的本地作用域中b的引用为200，不会去 test2() 中去搜索。如果删除掉 test2() 中 b=100的语句，那么test2函数调用时，在本地作用域找不到b的引用，会向上级enclosing作用域寻找，成功找到b的引用200，所以200在test2函数中生效！ 作用域在定义时生效：123456def test(): print a a = 100a = 200test() 这个例子会报错，因为在 test() 函数中，因为本地作用域有命名a的引用操作，所以 print a 会优先使用本地作用域的命名。但是定义在使用之后，所以会报错。 事实上，所有引入新命名的操作都作用于局部作用域。 官方文档这句话的意思，这里的局部作用域要以相对角度去理解。 global、nonlocal通过 global 和 nonlocal 两个关键字，可以将内层的变量引入到全局作用域。终于讲到了之前那个例子，弄懂了命名空间和作用域的基础上，就能很简单的理解那个例子了。 看具体的例子：12345678910111213141516171819def scope_test(): def do_local(): spam = "local spam" def do_nonlocal(): nonlocal spam spam = "nonlocal spam" def do_global(): global spam spam = "global spam" spam = "test spam" do_local() print("After local assignment:", spam) do_nonlocal() print("After nonlocal assignment:", spam) do_global() print("After global assignment:", spam)scope_test()print("In global scope:", spam) 输出是 1234After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam 如果不使用global和nonlocal，那么在本地作用域，对enclosing和global作用域则只是有只读权限，引入这两个关键字的声明，其实是在local作用域赋予了写的权限。 需要注意的是，python2中并不支持 nonlocal 关键字来重新关联作用域。 Globals() Locals()这两个方法是关于返回作用域的函数，前者返回全局作用域。后者返回当前的本地作用域。用这两个函数可以帮助理解namespace和scope，直接贴上我写的一段代码：1234567891011121314151617181920212223242526#!usr/bin/env python# -*- encoding: utf-8 -*-import osfrom sys import argvclass test: passdef test2(arg1,arg2): print(locals()) return arg1 + arg2def test3(): b = 2 def test4(): b = 200 return b test4() print(locals())a = 1b = 100test2(a,b)test3()print(globals()) 输出结果：123&#123;'arg2': 100, 'arg1': 1&#125;&#123;'test4': &lt;function test3.&lt;locals&gt;.test4 at 0x02AB36A8&gt;, 'b': 2&#125;&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x00F1A310&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': 'python.py', '__cached__': None, 'os': &lt;module 'os' from 'E:\\python\\lib\\os.py'&gt;, 'argv': ['python.py'], 'test': &lt;class '__main__.test'&gt;, 'test2': &lt;function test2 at 0x00EDD540&gt;, 'test3': &lt;function test3 at 0x02AB36F0&gt;, 'a': 1, 'b': 100&#125; 第一个字典记录的是test2()函数的本地作用域，可以看到只有两个参数的命名。 第二个字典是test3()函数的本地作用域，有一个函数对象和一个命名。 第三个是这个py文件的全局作用域信息，除了py文件中定义的函数、类、变量等，还有一些特殊变量__name__ __doc__ 内置模块 __builtins__ 我们引入的 os 模块也是作为一个模块对象，但是不同的是通过 form sys import argv 来引入的 argv 已经和原模块脱离联系，我们已经在本py文件中重新拷贝了一份。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python-语法]]></title>
      <url>%2F2017%2F04%2F15%2Fpython-%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[[TOC] 循环对于 dict ，关键字和对应的值可以使用 items() 同时取出来 12345678910111213141516171819&gt;&gt;&gt; d = &#123;'a': 1, 'b': 2, 'c': 3&#125;&gt;&gt;&gt; for key in d:... print(key)...abc&gt;&gt;&gt; for value in d.values():... print(value)...123&gt;&gt;&gt; for k,v in d.items():... print(k,v)...a 1b 2c 3 对于有大量元素的List，我们想要使用它的索引，可以使用 enumerate() 内置函数，它会将索引和索引指向的内容组成一个元组返回。 123456&gt;&gt;&gt; for i, v in enumerate(['tic', 'tac', 'toe']):... print(i, v)...0 tic1 tac2 toe 如果要同时在循环中，利用多个可迭代对象，可以使用 zip() 内置函数 12345678&gt;&gt;&gt; questions = ['name', 'quest', 'favorite color']&gt;&gt;&gt; answers = ['lancelot', 'the holy grail', 'blue']&gt;&gt;&gt; for q, a in zip(questions, answers):... print('What is your %s? It is %s.' %(q, a))...What is your name? It is lancelot.What is your quest? It is the holy grail.What is your favorite color? It is blue. 函数参数默认参数定义的时候直接赋值某些参数，使用场合是那些变化比较小，几乎不变的参数，这样调用函数免去输入这些参数就会很简单。 12def func(a,b,c=value) pass 值得一提的是，默认参数有个坑，很多文档都提到过。默认参数最好使用不变对象！如果你使用List作为默认参数，可能会出现： 1234567def f(a, L=[]): L.append(a) return Lprint(f(1))print(f(2))print(f(3)) 会输出： 123[1][1, 2][1, 2, 3] 事实上我们期望的是1，2，3的依次输出，说明之前的调用影响到了后面的调用。根本的解决方法是避免使用List等可变对象作为默认参数，不过你也可以这样来避免 12345def f(a, L=None): if L is None: L = [] L.append(a) return L 可变参数当调用函数时，需要传入多个参数时，定义的时候会非常不方便。可以在定义的时候使用 *arg 告诉python这是可变参数，调用时将所有参数组装成一个List或tuple传给 *arg 即可。 python简化了调用时的方法，我们只需要传入所有参数，交给python去封装成tuple。 可变参数放在位置参数和默认参数后面 12345678910&gt;&gt;&gt; def func(a,*args):... print('a =',a,'args =',args)&gt;&gt;&gt; func(1,2)a = 1 args = (1,)&gt;&gt;&gt; func(1,2,3,4)a = 1 args = (2,3,4)&gt;&gt;&gt; s = [1,2,3,4]&gt;&gt;&gt; func(1,*s) #经常像这样调用 关键字参数和可变参数类似，区别时调用时传入任意具有参数名的参数。拥有关键字函数的时候，在调用的时候以 key-value 的形式传参 关键字参数也是可以作为位置参数的，不过前提是没有可变参数 传入参数的顺序并不重要，因为时以 key-value 的形式传入，可以通过key找到匹配的参数 python 将传入的关键字参数 组成一个dict 关键字参数往往在函数定义参数列表的最后 12345678910111213&gt;&gt;&gt; def keyarguments(position,**kw): print('position arguement:',position) keys = sorted(kw.keys()) for key in keys: print('key arguements:',kw[key]) &gt;&gt;&gt; func('Allenware',sex='male',city='shenzhen')&gt;&gt;&gt; position arguement: Allenware city: shenzhen key arguements: male &gt;&gt;&gt; d = &#123;'sex':'male','city':'shenzhen'&#125;&gt;&gt;&gt; func('Allenware',**d) #更推荐的调用方法 排序是因为 dict 是无序的数据类型，这样可以规范输出。 命名关键字参数这个参数的作用是为了限制命名关键字的参数，只接受我们规定好的关键字参数，也就是命名的作用。并且可以提供默认值 123456789&gt;&gt;&gt; def namedkeyarguments(name,*,cit='Beijing',job): print('name :',position) print('city :',city) print('job :',job) &gt;&gt;&gt; namedkeyarguments('Allenware',city='Shenzhen',job='Coder')name : Allenwarecity : Shenzhenjob : Coder 注意：当函数用到多种参数类型时，这五种参数的定义顺序必须为：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 TIPs 若要在循环内部修改正在遍历的序列，建议首先创建一个副本。切片表示法使这尤其方便: 1234567&gt;&gt;&gt; words = ['cat', 'window', 'defenestrate']&gt;&gt;&gt; for w in words[:]: # Loop over a slice copy of the entire list.... if len(w) &gt; 6:... words.insert(0, w)...&gt;&gt;&gt; words['defenestrate', 'cat', 'window', 'defenestrate'] 循环可以有一个 else 子句，在 for 循环中，在迭代结束时执行，对于 while 则是false条件触发时执行。 pass 语句什么都不做，当然也有#TODO的作用 命名关键字参数使用 *, 加上命名参数的key值，如果是紧跟着可变参数，可以省去 * *args 和 **kw 是 python 常用的写法，一看就知道是什么意思。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[http消息]]></title>
      <url>%2F2017%2F04%2F09%2Fhttp%E6%B6%88%E6%81%AF%2F</url>
      <content type="text"><![CDATA[HeadersHTTP协议的Header总共分为三种，分别是General Headers、Entity Headers、Request/Response Headers 。目前最新的是基于HTTP/1.1的RFC2616，总共规定了47种头部字段。 [TOC] General Headers我把被Request和Response共享的Headers成为General Headers，具体有： 123456789general-header = Cache-Control | Connection | Date | Pragma | Trailer | Transfer-Encoding | Upgrade | Via | Warning Cache -Control 指定请求和响应遵循的缓存机制，单向work 12345Cache-Control:Public 可以被任何缓存所缓存Cache-Control:Private 内容只缓存到私有缓存中Cache-Control:no-cache 所有内容都不会被缓存 Connection 允许客户端和服务器指定与请求/响应连接有关的选项，keep-alive或者close Date 提供日期和时间标志,说明报文是什么时间创建的 Pragma 头域用来包含实现特定的指令，最常用的是Pragma:no-cache，和 Cache-Control：no-cache 作用相同。用于Http/1.1之前的版本还没有实现 Cache-Control 字段 Trailer 如果报文采用了分块传输编码(chunked transfer encoding) 方式,就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合 Transfer-Encoding 告知接收端为了保证报文的可靠传输,对报文采用了什么编码方式 Upgrade 给出了发送端可能想要”升级”使用的新版本和协议 Via 显示了报文经过的中间节点(代理,网嘎un) Entity HeadersEntityHeaders主要用来描述消息体（message body）的一些元信息，具体有： 12345678910entity-header = Allow | Content-Encoding | Content-Language | Content-Length | Content-Location | Content-MD5 | Content-Range | Content-Type | Expires | Last-Modified 其中，以Content为前缀的Headers主要描述了消息体的结构、大小、编码等信息，Expires描述了Entity的过期时间，Last-Modified描述了消息的最后修改时间。 Content-Length：消息的内容长度 Content-Type：请求实体对应的MIME信息，application/x-www-form-urlencoded或者响应返回的MIME类型 Content-Type: text/html; charset=utf-8 Expires：浏览器会在指定时间前都使用本地缓存 Last-Modified：用于指示资源的最后修改时间 Content-Encoding：服务端支持的返回内容压缩编码类型 Content-Location：请求资源可替代的另一地址 Content-Range：在整个返回体中本部分的字节位置 Allow：允许的Method，只出现在状态码为405的响应消息中 Request Headers在Request-Line后面紧跟着的就是Headers。我们在上面已经介绍了General Headers和Entity Headers，下面便是Request Headers定义： 1234567891011121314151617181920request-header = Accept | Accept-Charset | Accept-Encoding | Accept-Language | Authorization | Expect | From | Host | If-Match | If-Modified-Since | If-None-Match | If-Range | If-Unmodified-Since | Max-Forwards | Proxy-Authorization | Range | Referer | TE | User-Agent | Cookie Request Headers 扮演的角色其实就是一个Request消息的调节器。需要注意的是若一个headers名称不在上面列表中，则默认当做Entity Headers的字段。在HTTP/1.1中，除了HOST字段，其他都是可选的。 前缀为 Accept 的headers定义了客户端可以接受的媒介类型、语言和字符集等 Acceppt：text/html 代表浏览器可以接受的类型为 text/html，如果服务器无法返回html文档，会返回406。一般浏览器可以处理任何类型 Accept：*/* Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（compress，gzip） Accpet-Language：申明自己接收的语言 Accept-Charset：申明接收的字符集，如utf-8 From, Host, Referer 和User-Agent详细定义了客户端 如何初始化Request User-Agent：告诉服务端，消息来源的OS和浏览器信息 Referer：请求的上下文信息，即上一个网页的地址 Host：必须的报文头字段，指定服务端的域名和端口号，通常从url解析 From：发出请求用户的email Range：请求实体的一部分，指定范围 bytes=500-999 前缀为 If 的headers规定了服务器只能返回符合这些描述的资源，若不符合, 则会返回304 Not Modified。 If-Modified-Since ：带上浏览器缓存页面的最后修改时间，Server端会对比实际文件的最后修改时间（Response消息的Last-Modified字段），一样则返回304，有修改返回200 OK和文件内容。客户端丢弃旧内容，缓存新内容。 If-None-Match ：和Etag一起work，Client端再次请求同个资源时，带上上次Server端Response消息的Etag字段到If-None_Match中 若Request-Line中的Method为GET，请求中不包含消息体，若为POST，则会包含消息体。 一个具体的Request消息实例： 123456GET /articles/http-basics HTTP/1.1Host: www.articles.comConnection: keep-aliveCache-Control: no-cachePragma: no-cacheAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Response Headers下面是response-header的定义： 12345678910response-header = Accept-Ranges | Age | ETag | Location | Proxy-Authenticate | Retry-After | Server | Vary | WWW-Authenticate | Set-Cookie Age： 表示消息自server生成到现在的时长，单位是秒 ETag： 是对Entity进行MD5 hash运算的值，用来检测更改 Location： 被重定向的URL Server： 服务器标识 Vary：告诉下有代理是使用缓存还是从原始服务器请求 Set-Cookie：设置http Cookie]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python-常用数据结构]]></title>
      <url>%2F2017%2F04%2F09%2Fpython-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[Python学习笔记2-常用数据类型[TOC] python为何这么简洁方便python非常的简洁，如果用C语言100行才能干的事儿，python只需要10行、5行甚至一行。很重要的一个原因就是python支持的这些高级数据结构，节省了很多代码量。 List列表是python中最常用的数据类型。list是有序的集合，可以随时添加删除元素 [item1,item2 ...] 语法上是 [] 中的元素组成的有序集合，元素不必是同一类型，List中可以有List元素。 123&gt;&gt;&gt;language=['c','java','python']&gt;&gt;&gt;language['c','java','python'] 和 字符串 一样，List同样可以被索引和切片，List也是可迭代对象，不同的是List是可变数据类型。 常用API list(obj) 将对象强制转成list，比如 list(range(5)) list.append(obj) 在列表尾追加 obj list.insert(index,obj) index索引处插入 obj list.pop(obj=list[-1]) 移除列表中的元素(默认最后一个) list.remove(obj) 移除obj匹配的第一个对象 1234567891011121314&gt;&gt;&gt;s=[1,2,3,4,5,[6,7,8],9]&gt;&gt;&gt;s.append(0)[1, 2, 3, 4, 5, [6, 7, 8], 9, 0]&gt;&gt;&gt;s.insert(-1,-1)[1, 2, 3, 4, 5, [6, 7, 8], 9, -1, 0]&gt;&gt;&gt;s.pop(-5)[1, 2, 3, 4, 5, 9,-1, 0]&gt;&gt;&gt;s.sort()[-1, 0, 1, 2, 3, 4, 5, 5, 9]&gt;&gt;&gt;s.reverse()[9, 5, 5, 4, 3, 2, 1, 0, -1]&gt;&gt;&gt;s.count(5)2 利用python为list提供的这些API，我们可以很轻松实现栈和队列这两个数据结构，当然是在你不考虑插入查找操作的复杂度基础上。python的 collections ^collections 这个库中的队列是更好的选择。 12345678910&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; queue = deque(["Eric", "John", "Michael"])&gt;&gt;&gt; queue.append("Terry") # Terry arrives&gt;&gt;&gt; queue.append("Graham") # Graham arrives&gt;&gt;&gt; queue.popleft() # The first to arrive now leaves'Eric'&gt;&gt;&gt; queue.popleft() # The second to arrive now leaves'John'&gt;&gt;&gt; queue # Remaining queue in order of arrivaldeque(['Michael', 'Terry', 'Graham']) List的生成1.直接定义直接用[item1,item2, ...] 穷举法来构造处List 2.迭代在Python中，迭代是通过for ... in来完成的，而很多语言比如C或者Java，迭代list是通过下标索引完成的。python的抽象程度更高，对于 dict{key:value} 可以用 for key in dict 来进行迭代另一方面，python的迭代更加的通用，它适用于所有可迭代对象。可以用下面方法判断是否为可迭代对象 123&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance(List, Iterable) True 生成一个List很简单，结合之前的API和 for 关键字 123456&gt;&gt;&gt; squares = []&gt;&gt;&gt; for x in range(10):... squares.append(x**2)...&gt;&gt;&gt; squares[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 当然对于python而言，这种写法已经算是复杂了，之后会接触很多实用的python高级函数。 3.列表生成式上面的迭代写法，如果用列表生成式来写，那就是 1squares = [x**2 for x range(10)] python的语义已经非常清楚了，多写几次就能很快熟悉了。 列表生成式很大程度的体现了python的简洁高效的特点，还可以在表达式中添加过滤条件，处理函数等等。 12345678910&gt;&gt;&gt; vec = [-4, -2, 0, 2, 4]&gt;&gt;&gt; [x*2 for x in vec][-8, -4, 0, 4, 8]&gt;&gt;&gt; [x for x in vec if x &gt;= 0][0, 2, 4]&gt;&gt;&gt; [abs(x) for x in vec][4, 2, 0, 2, 4] 稍微复杂一些的用法 12345678910&gt;&gt;&gt; freshfruit = [' banana', ' loganberry ', 'passion fruit ']&gt;&gt;&gt; [weapon.strip() for weapon in freshfruit]['banana', 'loganberry', 'passion fruit']&gt;&gt;&gt; [(x, x**2) for x in range(6)][(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]&gt;&gt;&gt; vec = [[1,2,3], [4,5,6], [7,8,9]]&gt;&gt;&gt; [num for elem in vec for num in elem][1, 2, 3, 4, 5, 6, 7, 8, 9] Tuple元组是不可变对象，初始化之后就不可更改。所以，tuple 没有list中append() insert()这样的操作函数，tuple中的元素不可修改。在代码中，tuple带来的好处很多，要大胆的使用它。构造语句： 1&gt;&gt;&gt; t=(1,2,3,4,5) tuple的概念有一点很绕，tuple对象不可变，但是tuple可以包含list这种可变的对象。 1234567&gt;&gt;&gt; t = 12345, 54321, 'hello!'&gt;&gt;&gt; t[0] = 1...会提示修改失败&gt;&gt;&gt; t = ([1,2,3],4,5)&gt;&gt;&gt; t[0][2] = 4&gt;&gt;&gt; tt = ([1,2,4],4,5) 上面的例子，t这个tuple本身并没有变，只是其中的第一个元素内容变了。因为t[0]指向了list类型的可变对象。理解这一点，tuple就很简单了。 Setset可以看成是无重复，无序key的集合，它和数学中的集合一样，两个set之间可以进行交并的操作。 使用 set() 或者 { } 来创建，经常用于重复测试或者关系测试。 重复插入虽然不犯错，但不实际存储。 12345678910111213141516&gt;&gt;&gt; basket = &#123;'apple', 'orange', 'apple', 'pear', 'orange', 'banana'&#125;&gt;&gt;&gt; print(basket) # show that duplicates have been removed&#123;'orange', 'banana', 'pear', 'apple'&#125;&gt;&gt;&gt; a = set('abracadabra')&gt;&gt;&gt; b = set('alacazam')&gt;&gt;&gt; a # unique letters in a&#123;'a', 'r', 'b', 'c', 'd'&#125;&gt;&gt;&gt; a - b # letters in a but not in b&#123;'r', 'd', 'b'&#125;&gt;&gt;&gt; a | b # letters in either a or b&#123;'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'&#125;&gt;&gt;&gt; a &amp; b # letters in both a and b&#123;'a', 'c'&#125;&gt;&gt;&gt; a ^ b # letters in a or b but not both&#123;'r', 'd', 'b', 'm', 'z', 'l'&#125; Dictpython内置了dict，也就是以 key:value 的形式存储数据，具有极快的查找速度 dict在内部通过 hash 直接计算处 key 对用的 value 的地址，所以查找很快 key 的值不可变，所以不能用List来作为 key dict占用大量内存，这是肯定的，以空间换时间了 同一个字典不能有重复的key，新的会覆盖旧的 对一个字典执行 list(d.keys()) 将返回一个字典中所有关键字组成的无序列表（如果你想要排序，只需使用 sorted(d.keys()) ）。使用 in 关键字可以检查字典中是否存在某个关键字（指字典） 12345678910111213141516171819202122&gt;&gt;&gt; tel = &#123;'jack': 4098, 'sape': 4139&#125;&gt;&gt;&gt; tel['guido'] = 4127&gt;&gt;&gt; tel&#123;'sape': 4139, 'guido': 4127, 'jack': 4098&#125;&gt;&gt;&gt; tel['jack']4098&gt;&gt;&gt; del tel['sape']&gt;&gt;&gt; tel['irv'] = 4127&gt;&gt;&gt; tel&#123;'guido': 4127, 'irv': 4127, 'jack': 4098&#125;&gt;&gt;&gt; list(tel.keys())['irv', 'guido', 'jack']&gt;&gt;&gt; sorted(tel.keys())['guido', 'irv', 'jack']&gt;&gt;&gt; 'guido' in telTrue&gt;&gt;&gt; 'jack' not in telFalse&gt;&gt;&gt; d = &#123;&#125; #initialize&gt;&gt;&gt; dict(sape=4139, guido=4127, jack=4098) #可以直接利用关键字参数传入&#123;'sape': 4139, 'jack': 4098, 'guido': 4127&#125; TIPs 利用 del 语句来批量删除List 中的元素 元组只有一个元素时的定义 t=(0) 会有歧义，与 t=0 作用相同，所以用 t=(0,) 来消除冲突。 dict和set也有与列表生成式相似的生成式 12345&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;&#123;2: 4, 4: 16, 6: 36&#125;&gt;&gt;&gt; &#123;x for x in 'abracadabra' if x not in 'abc'&#125;&#123;'r', 'd'&#125; ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python-扬帆起航]]></title>
      <url>%2F2017%2F04%2F08%2Fpython-%E6%89%AC%E5%B8%86%E8%B5%B7%E8%88%AA%2F</url>
      <content type="text"><![CDATA[前言闲着无聊，重学python，记录总结。 Life is short,I use python. —From person I don’t konw [TOC] 学习环境linux和mac与生俱来，就比windows更适合windows。毕竟他们都是秉持着 一切皆对象 的原则。 python的安装无需多说，对于版本，我的看法是顺着时代，抛弃python2.x吧，虽然工作中很多库都建立在python2的依赖之上。但对于我们个人，直接学习python3.x是更聪明的选择。我的python版本是3.6 最好的学习资料还是推荐官方文档，有中文版 下面这张图是我偶然看见的，说明了python很多常用的语法 开发工具用过vim的小伙伴当然是不用多想，vim很适合开发python。 如果是喜欢IDE的童鞋，那就肯定是Pycharm了。jetbrains的软件都是非常赞的。当然python新手也推荐用这款软件，我之前也是一直在用，唯一的缺点就是启动时加载项目太慢了。 我自己使用的是sublime text3和相关的python package，sublime3界面比较好看，颜值吸引了我，专有的包管理器，扩展性不错。至于怎么配置，网上还是很多分享的。这里我只推荐两个package SublimeREPL ,这样就无需重复的保存，取cmd执行.py文件。在editor中可以直接编译运行py脚本 sublime3已经支持了函数声明跳转功能，但在项目文件变得杂多时，跳转结果并不准确，推荐ctags。这个大名鼎鼎的插件就不用多说了 上面三种方法对于初学者还是比较麻烦，尤其是第一和第三种。所以python3之后加入了idle代码解释器，下载之后，可以直接使用python自带的cmdline或者Idle的交互环境先学起来。 提示python解释器的注释 编码方式 1# -*- coding: utf-8 -*- 指定执行脚本的python解释器，必须在第一行，推荐下面的写法，让操作系统在env中寻找python解释器的路径 1#!/usr/bin/env python3 python中的字符串基本python支持单引号 &#39;str&#39; 和双引号 &quot;str&quot; 来修饰字符串，\ 用来转义。 123456789101112&gt;&gt;&gt; 'spam eggs' # single quotes'spam eggs'&gt;&gt;&gt; 'doesn\'t' # use \' to escape the single quote..."doesn't"&gt;&gt;&gt; "doesn't" # ...or use double quotes instead"doesn't"&gt;&gt;&gt; '"Yes," he said.''"Yes," he said.'&gt;&gt;&gt; "\"Yes,\" he said."'"Yes," he said.'&gt;&gt;&gt; '"Isn\'t," she said.''"Isn\'t," she said.' 可以看出来，单引号和双引号，相互之间的影响，是可以嵌套作用的。当然不推荐将简单的字符串写的如此复杂。 选用一种引号，再加上转义字符 \ 和 原始字符串 可以处理绝大部分的字符串。 原始字符串 ：r . r&#39;str&#39; 中的str默认不转义 12345&gt;&gt;&gt; print('C:\some\name') # here \n means newline!C:\someame&gt;&gt;&gt; print(r'C:\some\name') # note the r before the quoteC:\some\name 上面也可以用 print(&#39;C:\some\\name&#39;) 来避免冲突，但是明显不如使用 原始字符串 理解起来方便。 格式化和C语言类似，利用 % 来格式化输出，%s %d %f %x 分别用来代替字符串/整数/浮点数和十六进制整数,称为占位符。分不清楚的时候可以无需考虑直接使用 %s 1234&gt;&gt;&gt; 'Hello, %s' % 'world''Hello, world'&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)'Hi, Michael, you have $1000000.' 除了使用 % 来格式化，功能更多，使用起来更方便的是字符串自带的格式化函数 format ，具体用法看 str.format123456789101112131415161718192021222324252627282930313233343536# 位置参数print "&#123;0&#125; is &#123;1&#125; years old".format("Wilber", 28)print "&#123;&#125; is &#123;&#125; years old".format("Wilber", 28)print "Hi, &#123;0&#125;! &#123;0&#125; is &#123;1&#125; years old".format("Wilber", 28)# 关键字参数print "&#123;name&#125; is &#123;age&#125; years old".format(name = "Wilber", age = 28)# 下标参数li = ["Wilber", 28]print "&#123;0[0]&#125; is &#123;0[1]&#125; years old".format(li)# 填充与对齐# ^、&lt;、&gt;分别是居中、左对齐、右对齐，后面带宽度# :号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充print '&#123;:&gt;8&#125;'.format('3.14')print '&#123;:&lt;8&#125;'.format('3.14')print '&#123;:^8&#125;'.format('3.14')print '&#123;:0&gt;8&#125;'.format('3.14')print '&#123;:a&gt;8&#125;'.format('3.14')# 浮点数精度print '&#123;:.4f&#125;'.format(3.1415926)print '&#123;:0&gt;10.4f&#125;'.format(3.1415926)# 进制# b、d、o、x分别是二进制、十进制、八进制、十六进制print '&#123;:b&#125;'.format(11)print '&#123;:d&#125;'.format(11)print '&#123;:o&#125;'.format(11)print '&#123;:x&#125;'.format(11)print '&#123;:#x&#125;'.format(11)print '&#123;:#X&#125;'.format(11)# 千位分隔符print '&#123;:,&#125;'.format(15700000000) 多行字符串python使用三引号来处理多行字符串 12345print("""\Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to""") 字符串的高级特性 索引 字符串可以通过index访问，如 1str[0],str[1], ... str[len(str)-1] 还可以逆序访问 1str[-1],str[-2], ... 其中 str[len(str)-1] = str[-1] 切片 切片表达式 : str[a:b:c]从str字符串，按步长c，从下限a到上限b (不包含上限)，取出单个字符组成字符串 1234567&gt;&gt;&gt; word = 'abcdefghijklmn'&gt;&gt;&gt; word[0:3] # characters from position 0 (included) to 2 (excluded)'abc'&gt;&gt;&gt; word[5:10:2]'fhj'&gt;&gt;&gt; word[-10:-1:2]'ehikm' 当然不只是 字符串 这种数据类型才有 切片 特性，切片特性是可迭代对象共有的。 字符串是python中少有的不可变对象 python是动态语言，其中的不可变对象很少，比如tuple，字符串也是其中一种。 字符串的常用内置函数字符串是python的基本数据类型，但本质上，它是python封装的一个类对象，拥有着很多属性。 1234&gt;&gt;&gt;type(str)&lt;class 'type'&gt;&gt;&gt;&gt;dir(str)['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] dir(str) 以 list 的形式给出了字符串这个类的所有属性。常用的有： str.capitalize() 将字符串第一个元素大写 str.find(string,beg=0,end=len(str)) 检查str中是否还有string，找到返回起始索引 str.join(seq) 以str作为分隔，将seq中所有元素组成一个新的字符串 123&gt;&gt;&gt;word = 'Allenware'&gt;&gt;&gt;'-'.join(word)'A-l-l-e-n-w-a-r-e' str.split(str=&quot;&quot;,num=str.count(str)) 以 str 为分隔符切片 string，如果 num有指定值，则仅分隔 num 个子字符串 str.partition(str) 按string将str分为三段，返回一个包含三个元素的元组 123&gt;&gt;&gt;string='Allenware is very cool!'&gt;&gt;&gt;string.partition('is')('Allenware ', 'is', ' very cool!') str.strip() = str.lstrip() + str.rstrip() 截掉str左边右边空格 str.upper str.lower大小写转换]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[http协议]]></title>
      <url>%2F2017%2F04%2F08%2Fhttp%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[[TOC] Http DefinitionHTTP（Hypertext Transfer Protocol）就是超文本传输协议，它是现代互联网最重要也是最基本的协议。Http协议是无状态的、应用层协议，它是web开发的基础。 URL URL(Uniform Resource Locator) 地址用于描述一个网络上的资源。基本格式如下： 1234567891011schema://login@host[:port#]/path/..../[?query-string][#anchor] /* scheme: 协议名（如http,https,ftp） login: 登陆信息 host: 服务器IP/域名 port#:HTTP服务的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如http://www.cnblogs.com:8080 path: 资源路径 query-string: 发送给web服务器的数据 anchor: 锚 */ 举个例子： 123456789http://www.mywebsite.com/sj/test/test.aspx?name=sivergn&amp;x=true#stuff /* schema: http host: www.mywebsite.com path: /sj/test/test.aspx Query String: name=sviergn&amp;x=true Anchor: stuff */ URL的请求过程 当你在浏览器输入URLhttp://www.website.com的时候，浏览器发送一个Request去获取http://www.website.com的html。 服务器把Response发送回给浏览器。浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件。 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。当所有的文件都下载成功后， 网页就被显示出来了。 Request Method我们通过URL访问服务端获得资源，具体的操作由 http 协议的 request method 来定义。http/1.1 一共有八种操作： GET：向服务端发起获得资源的请求。GET 也是可以传递参数给服务端的，是将参数放在URL中携带到服务端，暴露在整篇网络环境中，很不安全。 POST：向指定的主机资源提交数据。一般都是向服务端提交表单数据进行处理。POST 提交的数据保存在http协议的body中。 PUT：向指定的主机资源上传最新的内容 DELETE：请求服务端删除Request-URL标识的资源 上面四种是用的最多的四种Method，有时候，我们将 PUT 和 DELETE 看作是POST的特殊实现。 HEAD：与GET方法类似，区别是只请求头部。用于测试和获得头部中的元数据 TRACE：回显请求 CONNECT：HTTP/1.1预留给一些代理服务器用，用于改变连接方式。 OPTIONS：测试服务端能支持的HTTP Method 对于Method常见的错误码： 405（Method Not Allowed） 是客户端的错误 501（Not Implemented） 是服务端的错误 GET实例： 1234GET /test/?id=11101&amp;name=Professional HTTP/1.1Host: www.test.comUser-Agent: Mozilla/5.0 (Windows; U;) Firefox/1.0.1Connection: Keep-Alive POST实例： 12345678POST / HTTP/1.1Host: www.test.com User-Agent: Mozilla/5.0 (Windows; U) Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivename=Professional&amp;id=11101 状态码通过URL和Method，客户端就可以发送一个完整的请求给服务端。当然服务端也会做出响应。状态码就是非常重要的一种响应，客户端通过状态码就可以了解服务端做出何种响应。HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别： 1XX 提示信息； 表示请求已被成功接收，告诉客户端可以继续发送下一个请求了，若如果已发送完毕可以忽略它。 2XX 成功 3XX 重定向； 要完成请求必须进行更进一步的处理 4XX 客户端错误；请求有语法错误或请求无法实现 5XX 服务器端错误；服务器未能实现合法的请求 常见的状态码1xx：Informational Messages这是 http/1.1 才支持的状态码，服务端可以发送一个 100-continue 告诉客户端继续发送消息，客户端如果已发送可以忽略。 2xx：成功告诉 client 接收到 Request 并成功处理，最常见的是 200 OK 202 Accepted: the request was accepted but may not include the resource in the response. This is useful for async processing on the server side. The server may choose to send information for monitoring. 204 No Content: there is no message body in the response. 205 Reset Content: indicates to the client to reset its document view. 206 Partial Content: indicates that the response only contains partial content. Additional headers indicate the exact range and content expiration information. 3xx：Redirection这个状态代表客户端需要重定向到其他URL获取资源，新的URL在Response中，浏览器会自动向新的URL发起Request 301 请永久到新的URL获取资源 303 资源暂时位于新的URL，新的URL记在 Location Response Header 中 304 告诉client请求的资源没有更新，可以直接使用client缓存中的备份。（当然有没有更新是靠头部中的标识进行hash计算的） 4xx：Client Error当客户端发出一个 bad request 或者请求无效资源时，server端会认为时client出错了。最常见的是 404 Not Found 。404 表示资源无效，在服务端上不存在。 400 Bad Request：请求语法错误 401 Unauthorized： 未经授权。可以通过带有 Unauthorized 的头部再次发起请求。还是401错误应该可以推断是没有证书。 403 Forbidden：服务器收到请求，但是拒绝提供服务 405 Method Not Allowed：request line中的method不合法 409 Conflict：冲突了。通常出现在多人协作时。 5xx：Server Error用于来表示server端出现了故障。最常见的是 500 Internal Server Error 服务器发生不可预期的错误。 501 Not Implemented：服务器不支持此方法 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常 Http消息结构消息格式http协议对 Request 和 Response 两种消息定义了下面的格式： 1234567message = &lt;start-line&gt; *(&lt;message-header&gt;) CRLF [&lt;message-body&gt;]&lt;start-line&gt; = Request-Line | Status-Line&lt;message-header&gt; = Field-Name ':' Field-Value 从上面定义我们可以看到，Http的Request和Response消息都是由三部分组成： 1231. start-line 开始行 2. header 消息头 3. body 消息体 对于start-line，又分为： 121. Request-Line : 'METHOD/path-to-resource http-version'2. Response-Line : 'http-version status-code message' 对于Headers则有如下几种： 123451. general headers2. entity headers3. request or response headers a. request specific headers. b. response specific headers. Request12GET http://www.google.com/ HTTP/1.1Host:www.google.com 用表格来表示： Request Line METHOD/path-to-resource HTTP/version-number Request Header Field1 : Value Request Header Field2 : Value 空行 空行 Request Body data(optional) Request Line／请求行 Method ：请求方法，如GET/POST path-to-resource ：所请求的资源在web服务器上的位置 HTTP/version-number：HTTP协议版本号。 Request Header，记录请求行以外的重要信息。 Request Body，携带提交给web服务器的数据。使用GET方法时，为空。 注意，Body和Header之间空一行。 Response Response Line HTTP/version-number status-code message Response Header Field1 : Value Response Header Field2 : Value 空行 空行 Response Body data(optional) Response Line／响应行 HTTP/version-number ：HTTP协议版本号 status-code ：状态码，反应服务器处理是否正常，告知出现的错误 message ：状态消息，同状态码对应。 Response Header / 响应头 ：记录响应体数据的相关信息。 Response Body / 响应体 ：携带需要向web服务器发送的数据。使用GET方法时，为空。 TIPs 对于GET方法，例如Http://localhost/login.php?username=aa&amp;password=1234 ，很明显能辩认出 ? 后就是 query-string ，易被网络爬虫爬取信息。 对于POST ，则会将提交的数据保存到HTTP的BODY中，比如上面的 username=aa&amp;password=1234 Reference 云栖社区 Http协议详解 HTTP协议详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为什么不用Markdown写设计文档?]]></title>
      <url>%2F2017%2F04%2F03%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8Markdown%E5%86%99%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[why write this blog之前只有在用一些笔记软件的时候偶尔接触过markdown这个东西，只知道是一种轻型的标记语言。现在工作还有各方面的需要，必须抽出一些时间系统的学习一下markdown。当然并不研究markdown的渲染原理，只学习用法。 [TOC] Markdown简介wiki上的介绍 Markdown is a lightweight markup language with plain text formatting syntax. It’s designed so that it can be converted to HTML and many other formats using a tool by the same name. 这么看，markdown的设计初衷肯定不是面向码农了，受众应该是经常写文档，写邮件的办公室一族了。 Markdown提供一套规定的语法，让写出的文档经过markdown processer的处理，转化为html，从而格式化你的.md文件。 当然，到了现在，Markdown的使用范围和影响已经渗透到各个行业，许多人日常的工作经常需要和它打交道。Github天生对md文件的支持，国内博客如简书也流行起markdown的方式来写博客。而抽出一小时左右的时间就能学会并使用它，还是非常值得，希望这篇blog会对你们有所帮助。 Editor工欲善其事，必先利其器。这里我推荐typero 下面是我写这篇博客时的截图 功能齐备 mac/windows的跨平台支持 界面清爽，cold style markdown的语法建和快捷键的绑定 准备好之后，开始markdown的学习。 区块元素标题标题用 # 来提示markdown引出标题，一共有六级标题，字体从大到小。合理的在一篇文章中使用标题，可以通过 [toc] 自动生成目录，而且让你的文章层次更加清楚。 1234# header1## header2...####### header6 header效果： 引用使用 &gt; 符号，引用的范围很广，通用解释、官方定义、他人专利都推荐用引用格式。 1&gt; 输入引用的内容 blockquotes效果： 列表un-orded list使用 - 来创建无序列表，+ * 具有相同的作用。 12345## programming language- c++- pyhton- go- java orded list有序列表，使用 1. item1 来创建，可以不按顺序，markdown语法解析器会自动识别 1234## popular1. javascipt2. pyhthon 3. java task list也就是html中的复选框，使用 - [] 来创建，默认不选中，- [x] 为默认选中的复选框 123- [] option1- [] option2- [x] options 效果如下： [ ] option1 [ ] option2 [x] option3 code block很多博客和笔记软件都支持加入代码块这个功能，可以保持代码的原貌。在typero中是使用 ` 来加入代码块，其他editor可能略有不同。1234```pythonfor a in list func(a) linksmarkdown支持两种link方式，inline和reference。两种方式都是用 [ ] 来修饰需要链接的对象。 inline links 在需要链接的对象后面，用括号加上links即可。用符号表示就是 [object] 后面加上 (links &quot;title&quot;) title是可选项。如果链接访问的本地主机的资源，可以用相对路径代替url 123[Baidu](http://baidu.com/ "baidu") is a famous company.See my [About](/about/) page for details. 效果： Baidu is a famous company. See my About page for details. reference links 与inline不同的是，它不直接指明链接的地址。而是在 [object] 后面跟上一个 [identifier] ，然后在文件的合适地方，给identifier定义一个links，这样object就能通过唯一的identifier找到自己的links。如果 [identifier] 为空，则默认和 [object] 同名 123[Tencent][qq] has been the best internet company in Asia.[qq]: http://allenware.github.io "Allenware" 效果： Tencent has been the best internet company in Asia. imagesimages的用法和links基本相似，只是加了一个 ! 在前面 inline式的语法如下： 123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg "Optional title") reference式的语法如下： 123![Alt text][id][id]: url/to/image "Optional title attribute" table创建表格，使用|header1|header2|...|headern| 来创建n列的表格，自动生成表格之后可以调节表格大小。 id name score 1 Allen 100 2 James 90 3 Victoria 95 Footnotes创建脚注 123You can create footnotes like this[^footnote].[^footnote]: Here is the *text* of the **footnote**. 效果： You can create footnotes like this[^footnote]. [^footnote]: Here is the text of the footnote. TIPs 需要注意markdown中有意义的符号，在写文章时可能会出现冲突，比如下面这个例子 11994. the year i was born 我的目的只是将它作为普通语句输入，解释markdown的语法解析器会把它误认为列表的提示键，这种情况需要引入 \ 转义符，正确用法如下 11994\. the year i was born 强调语法，使用**word** 来加粗，*word* 使字体变斜 _ 和 * 是同样的作用 TOC 用法，使用 [toc] 来生成目录，前面已介绍 下划线，可以使用下面的符号生成 1234---------********* 简短的代码引用可以用code就可以，比如 printf 是输出语句 插入image稍微麻烦一些，本地图片很方便，其他的可以用七牛云图片存储。 :smile :happy: 可以输入emoji ​比如：:open_hands: :clap: :haha: ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F02%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
